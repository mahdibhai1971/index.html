<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Mahdi Due Tracker</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Bootstrap CSS CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
    <!-- Bootstrap Icons CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet" />
    <!-- Tailwind CSS CDN for modern styling (used for utility classes) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <!-- PDF and Excel Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>

    <style>
        body {
            padding: 20px;
            background: #f9f9f9;
            font-family: 'Inter', sans-serif; /* Inter font used */
        }
        header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        .logo-circle {
            width: 45px;
            height: 45px;
            background-color: #0d6efd;
            color: white;
            border-radius: 50%;
            font-weight: 700;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.4rem;
            user-select: none;
        }
        header h1 {
            margin-left: 12px;
            font-size: 1.8rem;
            font-weight: 700;
            color: #0d6efd;
        }
        .nav-buttons {
            margin-bottom: 20px;
            display: flex; /* Navigation buttons made flexible */
            flex-wrap: wrap; /* Allowed to wrap on smaller screens */
            gap: 8px; /* Space between buttons */
        }
        .nav-buttons button {
            font-size: 14px;
            min-width: 110px;
            padding: 8px 12px; /* Padding adjusted for better look */
        }
        .page {
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .page.active {
            display: block;
            opacity: 1;
        }
        table th,
        table td {
            vertical-align: middle !important;
        }
        .form-select,
        .form-control {
            font-size: 14px;
        }
        .required-star {
            color: red;
            margin-left: 3px;
        }
        /* Popup Success Modal */
        .modal-success .modal-header {
            background-color: #198754;
            color: white;
        }
        .modal-error .modal-header {
            background-color: #dc3545;
            color: white;
        }
        .login-container {
            max-width: 400px;
            margin: 50px auto;
            padding: 30px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        .logged-in-user {
            margin-left: auto;
            display: flex;
            align-items: center;
        }
        .logged-in-user span {
            margin-right: 10px;
            font-weight: bold;
            color: #0d6efd;
        }
        /* Due Collection specific styles */
        .due-collect-selection button {
            margin-right: 10px;
            margin-bottom: 10px;
        }
        .due-collect-table-container {
            margin-top: 20px;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            overflow: hidden;
        }
        .filter-group {
            display: flex;
            align-items: flex-end;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap; /* Allowed to wrap */
        }
        .filter-group > div {
            flex-grow: 1;
            min-width: 150px; /* Ensure fields don't get too small */
        }
        .filter-group .form-label {
            margin-bottom: 5px;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            .nav-buttons {
                flex-direction: column;
                align-items: stretch;
            }
            .nav-buttons button {
                width: 100%;
                margin-right: 0;
                margin-bottom: 8px;
            }
            .filter-group {
                flex-direction: column;
                align-items: stretch;
            }
            .filter-group > div {
                min-width: unset;
                width: 100%;
            }
            .col-md-2, .col-md-3, .col-md-6 {
                flex: 0 0 100%;
                max-width: 100%;
            }
            .row.g-2 > * {
                padding-left: var(--bs-gutter-x, 0);
                padding-right: var(--bs-gutter-x, 0);
            }
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #0d6efd;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay" style="display: flex;">
        <div class="spinner"></div>
        <p class="ms-3 text-gray-700">Loading data...</p>
    </div>

    <!-- Header -->
    <header>
        <div class="logo-circle">MH</div>
        <h1>Mahdi Due Tracker</h1>
        <div class="logged-in-user" id="loggedInUserDisplay" style="display: none;">
            <span id="currentUsername"></span>
            <button class="btn btn-outline-danger btn-sm" onclick="logout()">Logout</button>
        </div>
    </header>

    <!-- Firebase User ID Display (Added for debugging/clarity) -->
    <div id="firebaseUserIdContainer" class="bg-blue-100 text-blue-800 p-3 rounded-lg mb-4 text-sm flex items-center justify-between shadow-sm" style="display:none;">
        <span>Your Firebase User ID: <span id="firebaseUserIdDisplay" class="font-semibold text-gray-700 break-words">Loading...</span></span>
        <button id="copyFirebaseUserIdBtn" class="ml-2 px-3 py-1 bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 text-xs">Copy</button>
    </div>


    <!-- Nav Buttons -->
    <div class="nav-buttons" id="mainNavButtons" style="display: none;">
        <button class="btn btn-primary" onclick="showPage('dueListPage')">Due List</button>
        <button class="btn btn-success" onclick="showPage('incomingFundsPage')">Incoming Funds</button>
        <button class="btn btn-secondary" onclick="showPage('dueCollectPage')">Due Collect</button>
        <button class="btn btn-warning" onclick="showPage('paidReportPage')">Paid Report</button>
        <button class="btn btn-secondary" onclick="showPage('adminPage')">Admin Panel</button>
        <button class="btn btn-info" onclick="showPage('infoPage')">Info</button>
    </div>

    <!-- Page: Login -->
    <div id="loginPage" class="page active">
        <div class="login-container">
            <h4 class="mb-3 text-center">Login to Mahdi Due Tracker</h4>
            <form id="loginForm" onsubmit="login(event)">
                <div class="mb-3">
                    <label for="usernameInput" class="form-label">Username:</label>
                    <input type="text" id="usernameInput" class="form-control" required />
                </div>
                <div class="mb-3">
                    <label for="passwordInput" class="form-label">Password:</label>
                    <input type="password" id="passwordInput" class="form-control" required />
                </div>
                <button type="submit" class="btn btn-primary w-100">Login</button>
            </form>
            <div class="alert alert-danger mt-3" id="loginError" style="display:none;"></div>
            <div class="mt-3 text-center">
                <a href="#" onclick="showForgotPasswordModal()">Forgot Password?</a>
            </div>
        </div>
    </div>

    <!-- Page: Due List -->
    <div id="dueListPage" class="page">
        <h4>Due List Entry Form</h4>
        <form id="dueEntryForm" onsubmit="addDueEntry(event)" class="mb-3">
            <div class="row g-2 align-items-end">
                <div class="col-md-3">
                    <label for="dueName" class="form-label">Name <span class="required-star">*</span></label>
                    <select id="dueName" class="form-select" required></select>
                </div>
                <div class="col-md-3">
                    <label for="duePurpose" class="form-label">Purpose <span class="required-star">*</span></label>
                    <input type="text" id="duePurpose" class="form-control" required />
                </div>
                <div class="col-md-2">
                    <label for="dueAmount" class="form-label">Amount <span class="required-star">*</span></label>
                    <input type="number" id="dueAmount" class="form-control" min="0" step="any" required />
                </div>
                <div class="col-md-2">
                    <label for="dueDate" class="form-label">Date <span class="required-star">*</span></label>
                    <input type="date" id="dueDate" class="form-control" required />
                </div>
                <div class="col-md-2">
                    <label for="dueStatus" class="form-label">Status <span class="required-star">*</span></label>
                    <select id="dueStatus" class="form-select" required>
                        <option value="Due" selected>Due</option>
                    </select>
                </div>
            </div>
            <button type="submit" class="btn btn-primary mt-3">Add Due Entry</button>
        </form>

        <div class="row mb-2">
            <div class="col-md-6 filter-group">
                <div>
                    <label for="dueFilterName" class="form-label">Filter by Name:</label>
                    <select id="dueFilterName" class="form-select" onchange="filterDueList()">
                        <option value="all" selected>All</option>
                    </select>
                </div>
                <div>
                    <label for="dueSearchInput" class="form-label">Search:</label>
                    <input type="text" id="dueSearchInput" class="form-control" placeholder="Search name, purpose, amount, date..." onkeyup="searchDueList()" />
                </div>
            </div>
            <div class="col-md-6 d-flex align-items-end justify-content-end">
                <button class="btn btn-primary me-2" onclick="exportDuePDF()">Export PDF</button>
                <button class="btn btn-success" onclick="exportDueExcel()">Export Excel</button>
            </div>
        </div>

        <table id="dueTable" class="table table-bordered table-striped align-middle">
            <thead class="table-primary">
                <tr>
                    <th>Serial</th>
                    <th>Name</th>
                    <th>Purpose</th>
                    <th>Amount</th>
                    <th>Date</th>
                    <th>Status</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody></tbody>
            <tfoot>
                <tr>
                    <th colspan="2">Total Due Amount</th>
                    <th id="dueTotalAmount" colspan="5"></th>
                </tr>
            </tfoot>
        </table>
    </div>

    <!-- Page: Incoming Funds -->
    <div id="incomingFundsPage" class="page">
        <h4>Incoming Funds Entry Form</h4>
        <form id="incomingEntryForm" onsubmit="addIncomingEntry(event)" class="mb-3">
            <div class="row g-2 align-items-end">
                <div class="col-md-3">
                    <label for="incomingName" class="form-label">Name <span class="required-star">*</span></label>
                    <select id="incomingName" class="form-select" required></select>
                </div>
                <div class="col-md-3">
                    <label for="incomingPurpose" class="form-label">Purpose <span class="required-star">*</span></label>
                    <input type="text" id="incomingPurpose" class="form-control" required />
                </div>
                <div class="col-md-2">
                    <label for="incomingAmount" class="form-label">Amount <span class="required-star">*</span></label>
                    <input type="number" id="incomingAmount" class="form-control" min="0" step="any" required />
                </div>
                <div class="col-md-2">
                    <label for="incomingDate" class="form-label">Date <span class="required-star">*</span></label>
                    <input type="date" id="incomingDate" class="form-control" required />
                </div>
                <div class="col-md-2">
                    <label for="incomingStatus" class="form-label">Status <span class="required-star">*</span></label>
                    <select id="incomingStatus" class="form-select" required>
                        <option value="Due" selected>Due</option>
                    </select>
                </div>
            </div>
            <button type="submit" class="btn btn-success mt-3">Add Incoming Entry</button>
        </form>

        <div class="row mb-2">
            <div class="col-md-6 filter-group">
                <div>
                    <label for="incomingFilterName" class="form-label">Filter by Name:</label>
                    <select id="incomingFilterName" class="form-select" onchange="filterIncomingList()">
                        <option value="all" selected>All</option>
                    </select>
                </div>
                <div>
                    <label for="incomingSearchInput" class="form-label">Search:</label>
                    <input type="text" id="incomingSearchInput" class="form-control" placeholder="Search name, purpose, amount, date..." onkeyup="searchIncomingList()" />
                </div>
            </div>
            <div class="col-md-6 d-flex align-items-end justify-content-end">
                <button class="btn btn-primary me-2" onclick="exportIncomingPDF()">Export PDF</button>
                <button class="btn btn-success" onclick="exportIncomingExcel()">Export Excel</button>
            </div>
        </div>

        <table id="incomingTable" class="table table-bordered table-striped align-middle">
            <thead class="table-success">
                <tr>
                    <th>Serial</th>
                    <th>Name</th>
                    <th>Purpose</th>
                    <th>Amount</th>
                    <th>Date</th>
                    <th>Status</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody></tbody>
            <tfoot>
                <tr>
                    <th colspan="2">Total Due Amount</th>
                    <th id="incomingTotalAmount" colspan="5"></th>
                </tr>
            </tfoot>
        </table>
    </div>

    <!-- Page: Due Collect -->
    <div id="dueCollectPage" class="page">
        <h4>Due Collection</h4>
        <div class="mb-3 due-collect-selection">
            <button class="btn btn-primary" onclick="displayCollectionTable('due')">Collect from Due List</button>
            <button class="btn btn-success" onclick="displayCollectionTable('incoming')">Collect from Incoming Funds</button>
        </div>

        <div id="dueCollectTableContainer" class="due-collect-table-container">
            <!-- Dynamic table will be loaded here -->
            <p class="text-center text-muted p-3">Select a source (Due List or Incoming Funds) to start collecting.</p>
        </div>
    </div>

    <!-- Page: Paid Report -->
    <div id="paidReportPage" class="page">
        <h4>Paid Report</h4>
        <div class="row mb-2">
            <div class="col-md-6 filter-group">
                <div>
                    <label for="paidFilterCategory" class="form-label">Filter by Category:</label>
                    <select id="paidFilterCategory" class="form-select" onchange="filterPaidList()">
                        <option value="all" selected>All</option>
                    </select>
                </div>
                <div>
                    <label for="paidSearchInput" class="form-label">Search:</label>
                    <input type="text" id="paidSearchInput" class="form-control" placeholder="Search name, purpose, amount, date, receipt..." onkeyup="searchPaidReport()" />
                </div>
            </div>
            <div class="col-md-6 d-flex align-items-end justify-content-end">
                <button class="btn btn-primary me-2" onclick="exportPaidPDF()">Export PDF</button>
                <button class="btn btn-success" onclick="exportPaidExcel()">Export Excel</button>
                <h6 class="ms-3">Total Entries: <span id="paidCount">0</span></h6>
            </div>
        </div>

        <table id="paidTable" class="table table-bordered table-striped align-middle">
            <thead class="table-warning">
                <tr>
                    <th>Serial</th>
                    <th>Receipt No.</th>
                    <th>Name</th>
                    <th>Purpose</th>
                    <th>Amount</th>
                    <th>Date</th>
                    <th>Status</th>
                    <th>Category</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>

    <!-- Page: Admin Panel -->
    <div id="adminPage" class="page">
        <h4>Admin Panel</h4>

        <div class="card mb-4">
            <div class="card-header bg-primary text-white">
                <h5>Add New Login User</h5>
            </div>
            <div class="card-body">
                <form id="addLoginForm" onsubmit="addLoginUser(event)">
                    <div class="mb-3">
                        <label for="newUsernameInput" class="form-label">Username:</label>
                        <input type="text" id="newUsernameInput" class="form-control" required />
                    </div>
                    <div class="mb-3">
                        <label for="newPasswordInput" class="form-label">Password:</label>
                        <input type="password" id="newPasswordInput" class="form-control" required />
                    </div>
                    <div class="mb-3">
                        <label for="newSecurityQuestionInput" class="form-label">Security Question:</label>
                        <select id="newSecurityQuestionInput" class="form-select" required>
                            <option value="" disabled selected>Select a security question</option>
                            <option value="We need your number to proceed — could you confirm it?">We need your number to proceed — could you confirm it?</option>
                            <option value="We need your district to proceed - Could you confirm it?">We need your district to proceed - Could you confirm it?</option>
                            <option value="We need your secret number to verify you - could you confirm it?">We need your secret number to verify you - could you confirm it?</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="newSecurityAnswerInput" class="form-label">Security Answer:</label>
                        <input type="text" id="newSecurityAnswerInput" class="form-control" required />
                    </div>
                    <button type="submit" class="btn btn-primary">Add Login User</button>
                </form>
            </div>
        </div>

        <div class="card mb-4">
            <div class="card-header bg-success text-white">
                <h5>Add Name for Dropdowns</h5>
            </div>
            <div class="card-body">
                <form id="addDropdownNameForm" onsubmit="addDropdownName(event)">
                    <div class="mb-3">
                        <label for="newDropdownNameInput" class="form-label">Name:</label>
                        <input type="text" id="newDropdownNameInput" class="form-control" placeholder="Enter new name for dropdowns" required />
                    </div>
                    <button type="submit" class="btn btn-success">Add Name</button>
                </form>
            </div>
        </div>

        <div class="mb-3">
            <button class="btn btn-secondary me-2" onclick="showLoginUsers()">Show Login Users</button>
            <button class="btn btn-info me-2" onclick="showDropdownNames()">Show Dropdown Names</button>
            <!-- Note about Backup/Restore: Removed as Firebase manages persistence. -->
            <p class="mt-3 text-sm text-gray-600">
                **Note:** Firebase automatically saves and backs up your data, so local backup/restore options have been removed. You can export your data from the Firebase console.
            </p>
        </div>

        <!-- Modals for displaying lists (Bootstrap Modals) -->
        <div id="loginUserModal" class="modal fade" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog modal-dialog-scrollable">
                <div class="modal-content">
                    <div class="modal-header bg-primary text-white">
                        <h5 class="modal-title">Login Users List</h5>
                        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <ul id="loginUserList" class="list-group"></ul>
                    </div>
                </div>
            </div>
        </div>

        <div id="dropdownNameModal" class="modal fade" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog modal-dialog-scrollable">
                <div class="modal-content">
                    <div class="modal-header bg-success text-white">
                        <h5 class="modal-title">Dropdown Names List</h5>
                        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <ul id="dropdownNameList" class="list-group"></ul>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- Page: Info -->
    <div id="infoPage" class="page">
        <h4>Info</h4>
        <p>This is Mahdi Due Tracker, a simple and efficient tool to track due amounts, incoming funds, and paid reports. Developed by Mahdi Bhai.</p>
        <p class="text-sm text-gray-600 mt-4">
            **Important Security Note:** Custom login users (like 'admin') used in this application are stored in a public collection in the Firebase database. This means that anyone using this app ID can view or modify these custom login user details unless the database security rules are changed. For a real-world application, Firebase Authentication (email/password, Google Sign-In, etc.) should be used for user authentication, which is much more secure.
        </p>
    </div>

    <!-- Modal Template for Success -->
    <div class="modal fade" id="successModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content modal-success">
                <div class="modal-header">
                    <h5 class="modal-title">Success</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="successModalBody"></div>
            </div>
        </div>
    </div>

    <!-- Modal Template for Error -->
    <div class="modal fade" id="errorModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content modal-error">
                <div class="modal-header">
                    <h5 class="modal-title">Error</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="errorModalBody"></div>
            </div>
        </div>
    </div>

    <!-- Custom Confirmation Modal HTML (Bootstrap based) -->
    <div class="modal fade" id="confirmationModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header bg-warning text-dark">
                    <h5 class="modal-title">Confirmation</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="confirmationModalBody"></div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="confirmActionButton">Confirm</button>
                </div>
            </div>
        </div>
    </div>

    <!-- New Modal for Editing Login Users -->
    <div class="modal fade" id="editLoginUserModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header bg-warning text-dark">
                    <h5 class="modal-title">Edit Login User</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="editLoginForm">
                        <input type="hidden" id="editUserDocId" /> <!-- Changed to docId for Firestore -->
                        <div class="mb-3">
                            <label for="editUsernameInput" class="form-label">Username:</label>
                            <input type="text" id="editUsernameInput" class="form-control" required />
                        </div>
                        <div class="mb-3">
                            <label for="editPasswordInput" class="form-label">Password:</label>
                            <input type="password" id="editPasswordInput" class="form-control" placeholder="Leave empty to keep current password" />
                        </div>
                        <div class="mb-3">
                            <label for="editSecurityQuestionInput" class="form-label">Security Question:</label>
                            <select id="editSecurityQuestionInput" class="form-select">
                                <option value="" disabled selected>Select your security question</option>
                                <option value="We need your number to proceed — could you confirm it?">We need your number to proceed — could you confirm it?</option>
                                <option value="We need your district to proceed - Could you confirm it?">We need your district to proceed - Could you confirm it?</option>
                                <option value="We need your secret number to verify you - could you confirm it?">We need your secret number to verify you - could you confirm it?</option>
                            </select>
                        </div>
                        <div class="mb-3">
                            <label for="editSecurityAnswerInput" class="form-label">Security Answer:</label>
                            <input type="text" id="editSecurityAnswerInput" class="form-control" placeholder="Enter security answer" />
                        </div>
                        <button type="button" class="btn btn-primary w-100" onclick="saveEditedLoginUser()">Save Changes</button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- New Modal for Forgot Password -->
    <div class="modal fade" id="forgotPasswordModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header bg-info text-white">
                    <h5 class="modal-title">Reset Password</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="resetPasswordForm" onsubmit="resetPassword(event)">
                        <div class="mb-3">
                            <label for="resetUsernameInput" class="form-label">Username:</label>
                            <input type="text" id="resetUsernameInput" class="form-control" required />
                        </div>
                        <div class="mb-3">
                            <label for="resetSecurityQuestionInput" class="form-label">Security Question:</label>
                            <select id="resetSecurityQuestionInput" class="form-select" required>
                                <option value="" disabled selected>Select your security question</option>
                                <option value="We need your number to proceed — could you confirm it?">We need your number to proceed — could you confirm it?</option>
                                <option value="We need your district to proceed - Could you confirm it?">We need your district to proceed - Could you confirm it?</option>
                                <option value="We need your secret number to verify you - could you confirm it?">We need your secret number to verify you - could you confirm it?</option>
                            </select>
                        </div>
                        <div class="mb-3">
                            <label for="resetSecurityAnswerInput" class="form-label">Security Answer:</label>
                            <input type="text" id="resetSecurityAnswerInput" class="form-control" required />
                        </div>
                        <div class="mb-3">
                            <label for="newPasswordResetInput" class="form-label">New Password:</label>
                            <input type="password" id="newPasswordResetInput" class="form-control" required />
                        </div>
                        <div class="mb-3">
                            <label for="confirmPasswordResetInput" class="form-label">Confirm New Password:</label>
                            <input type="password" id="confirmPasswordResetInput" class="form-control" required />
                        </div>
                        <button type="submit" class="btn btn-primary w-100">Reset Password</button>
                    </form>
                </div>
            </div>
        </div>
    </div>


    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Firebase SDKs -->
    <script type="module">
        // Firebase Import statements
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js"; // Updated SDK version
        import { getFirestore, collection, addDoc, getDocs, updateDoc, deleteDoc, doc, onSnapshot, query, where, writeBatch, setDoc } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-firestore.js"; // Updated SDK version
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-auth.js"; // Updated SDK version

        // Your web app's Firebase configuration (Please ensure these match your Firebase project)
        const firebaseConfig = {
            apiKey: "AIzaSyD3wm6c52930LeSZsUIXkTyOYW-4ouCXQk",
            authDomain: "mahdiduetracker-6c02f.firebaseapp.com",
            projectId: "mahdiduetracker-6c02f",
            storageBucket: "mahdiduetracker-6c02f.firebasestorage.app",
            messagingSenderId: "301972283046",
            appId: "1:301972283046:web:bd0ac401f7237808349e67",
            measurementId: "G-0HJ41H0DCY"
        };

        // Initialize Firebase variables
        let app;
        let db;
        let auth;
        let firebaseUserId = ''; // Firebase authentication user ID
        let isAuthReady = false; // Flag to ensure Firebase auth is ready

        // Global variables for Firebase config and App ID from Canvas environment (if available)
        // Using the new projectId as the default appIdEnv
        const appIdEnv = typeof __app_id !== 'undefined' ? __app_id : 'mahdiduetracker-6c02f'; // Updated default appIdEnv
        const firebaseConfigEnv = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : firebaseConfig; // Use provided config if available, else fallback

        // --- Data storage variables (now populated from Firebase) ---
        let dueEntries = [];
        let incomingEntries = [];
        let paidEntries = [];
        let loginUsers = []; // Stores login users with username and password, and security question/answer
        let dropdownNames = []; // Stores names for dropdowns
        let receiptCounter = 0; // For unique receipt numbers, fetched from Firebase
        let loggedInUser = null; // Stores currently logged in custom username

        // For Bootstrap Modals
        const loginUserModal = new bootstrap.Modal(document.getElementById('loginUserModal'));
        const dropdownNameModal = new bootstrap.Modal(document.getElementById('dropdownNameModal'));
        const successModal = new bootstrap.Modal(document.getElementById('successModal'));
        const successModalBody = document.getElementById('successModalBody');
        const errorModal = new bootstrap.Modal(document.getElementById('errorModal'));
        const errorModalBody = document.getElementById('errorModalBody');
        const confirmationModal = new bootstrap.Modal(document.getElementById('confirmationModal'));
        const confirmationModalBody = document.getElementById('confirmationModalBody');
        const confirmActionButton = document.getElementById('confirmActionButton');
        const editLoginUserModal = new bootstrap.Modal(document.getElementById('editLoginUserModal'));
        const forgotPasswordModal = new bootstrap.Modal(document.getElementById('forgotPasswordModal'));

        let confirmCallback = null; // Callback for confirmation modal

        // Global filter states for Due List and Incoming Funds pages
        let currentDueFilter = 'all';
        let currentIncomingFilter = 'all';
        let currentPaidFilterCategory = 'all'; // New filter state for Paid Report

        // DOM elements for loading overlay
        const loadingOverlay = document.getElementById('loadingOverlay');
        const firebaseUserIdContainer = document.getElementById('firebaseUserIdContainer');
        const firebaseUserIdDisplay = document.getElementById('firebaseUserIdDisplay');
        const copyFirebaseUserIdBtn = document.getElementById('copyFirebaseUserIdBtn');


        /**
         * Initializes Firebase and sets up authentication.
         * Sets up listeners for all data collections.
         */
        window.onload = async () => {
            try {
                // Show loading overlay
                loadingOverlay.style.display = 'flex';

                app = initializeApp(firebaseConfigEnv);
                db = getFirestore(app);
                auth = getAuth(app);

                // Authenticate user
                if (typeof __initial_auth_token !== 'undefined') {
                    // Use custom token if provided (for Canvas environment)
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    // Sign in anonymously for general web use or if no custom token
                    await signInAnonymously(auth);
                }

                // Listen for auth state changes
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        firebaseUserId = user.uid; // Set Firebase userId
                        firebaseUserIdDisplay.textContent = firebaseUserId;
                        firebaseUserIdContainer.style.display = 'flex'; // Show Firebase User ID display

                        isAuthReady = true; // Mark auth as ready
                        await setupRealtimeListeners(); // Start listening for data once auth is ready
                        checkLoginStatus(); // Check the custom login status
                    } else {
                        // This case typically means user is signed out, or initial anonymous sign-in failed.
                        // For this app, we force anonymous sign-in if no token.
                        console.error("Firebase Auth state changed to no user. This should not happen if signInAnonymously is successful.");
                        // Handle unauthenticated state if necessary (e.g., show login page only)
                        showPage('loginPage');
                    }
                    loadingOverlay.style.display = 'none'; // Hide loading message once auth is done
                });

            } catch (error) {
                console.error("Error initializing Firebase or signing in:", error);
                loadingOverlay.style.display = 'none'; // Hide loading even on error
                showError('Failed to load Firebase or sign in. Please check console.');
                showPage('loginPage'); // Fallback to login page on error
            }
        };

        /**
         * Sets up real-time listeners for all data collections in Firestore.
         */
        async function setupRealtimeListeners() {
            if (!isAuthReady || !firebaseUserId) {
                console.warn("Firebase authentication not ready or user ID not set. Cannot set up listeners.");
                return;
            }

            // --- Listener for Due Entries ---
            const dueQuery = query(collection(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/dueEntries`));
            onSnapshot(dueQuery, (snapshot) => {
                dueEntries = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                // Ensure isEditing and originalAmount exist for compatibility
                dueEntries.forEach(entry => {
                    if (entry.isEditing === undefined) entry.isEditing = false;
                    if (entry.originalAmount === undefined) entry.originalAmount = entry.amount; // Backfill original amount
                });
                renderDueList();
            }, (error) => {
                console.error("Error listening to due entries:", error);
                showError("Error loading due entries: " + error.message);
            });

            // --- Listener for Incoming Entries ---
            const incomingQuery = query(collection(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/incomingEntries`));
            onSnapshot(incomingQuery, (snapshot) => {
                incomingEntries = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                // Ensure isEditing and originalAmount exist for compatibility
                incomingEntries.forEach(entry => {
                    if (entry.isEditing === undefined) entry.isEditing = false;
                    if (entry.originalAmount === undefined) entry.originalAmount = entry.amount; // Backfill original amount
                });
                renderIncomingList();
            }, (error) => {
                console.error("Error listening to incoming entries:", error);
                showError("Error loading incoming entries: " + error.message);
            });

            // --- Listener for Paid Entries ---
            const paidQuery = query(collection(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/paidEntries`));
            onSnapshot(paidQuery, (snapshot) => {
                paidEntries = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderPaidReport();
                populatePaidCategoryFilter();
            }, (error) => {
                console.error("Error listening to paid entries:", error);
                showError("Error loading paid entries: " + error.message);
            });

            // --- Listener for Dropdown Names (single document with an array) ---
            const dropdownNamesDocRef = doc(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/metadata/dropdownNames`);
            onSnapshot(dropdownNamesDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    dropdownNames = docSnap.data().names || [];
                } else {
                    dropdownNames = [];
                    // Optionally create the document if it doesn't exist
                    // setDoc(dropdownNamesDocRef, { names: [] });
                }
                populateNameDropdowns();
            }, (error) => {
                console.error("Error listening to dropdown names:", error);
                showError("Error loading dropdown names: " + error.message);
            });

            // --- Listener for Login Users (public collection for custom login) ---
            // Changed path from /public/loginUsers to /loginUsers to fix "odd number of segments" error
            // Now directly uses 'loginUsers' as a top-level collection
            const loginUsersQuery = query(collection(db, `loginUsers`));
            onSnapshot(loginUsersQuery, (snapshot) => {
                loginUsers = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                // Ensure default admin user exists if not present
                if (loginUsers.length === 0 || !loginUsers.some(user => user.username === 'admin')) {
                    // Add default admin if not found. For simplicity, let's just add it if missing and not worry about fixed ID.
                    addDoc(collection(db, `loginUsers`), { // Changed path
                        username: 'admin',
                        password: 'password',
                        securityQuestion: 'We need your number to proceed — could you confirm it?',
                        securityAnswer: 'admin'
                    }).then(() => console.log("Default admin user added."))
                      .catch(e => console.error("Error adding default admin:", e));
                }
                // Ensure existing users have securityQuestion and securityAnswer fields after load
                loginUsers = loginUsers.map(user => {
                    if (user.securityQuestion === undefined) user.securityQuestion = '';
                    if (user.securityAnswer === undefined) user.securityAnswer = '';
                    return user;
                });
                checkLoginStatus(); // Re-check login status if loginUsers data changes
            }, (error) => {
                console.error("Error listening to login users:", error);
                showError("Error loading login users: " + error.message);
            });

            // --- Listener for Receipt Counter ---
            const receiptCounterDocRef = doc(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/metadata/receiptCounter`);
            onSnapshot(receiptCounterDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    receiptCounter = docSnap.data().counter || 0;
                } else {
                    receiptCounter = 0;
                    // Create the document with initial counter if it doesn't exist
                    setDoc(receiptCounterDocRef, { counter: 0 }).catch(e => console.error("Error creating receipt counter doc:", e));
                }
            }, (error) => {
                console.error("Error listening to receipt counter:", error);
                showError("Error loading receipt counter: " + error.message);
            });
        }

        // --- Utility Functions for Modals ---

        // Show success modal with message
        function showSuccess(message) {
            console.log("Success:", message);
            successModalBody.textContent = message;
            successModal.show();
            setTimeout(() => successModal.hide(), 2000);
        }

        // Show error modal with message
        function showError(message) {
            console.error("Error:", message);
            errorModalBody.textContent = message;
            errorModal.show();
            setTimeout(() => errorModal.hide(), 3000);
        }

        // Custom Confirmation Modal (uses Bootstrap Modal)
        function showConfirmation(message, callback, cancelCallback = null) {
            console.log("Showing confirmation:", message);
            confirmationModalBody.textContent = message;
            confirmCallback = callback;
            confirmActionButton.onclick = () => {
                if (confirmCallback) {
                    confirmCallback();
                }
                confirmationModal.hide();
            };
            const cancelButton = document.querySelector('#confirmationModal .btn-secondary');
            if (cancelCallback) {
                cancelButton.onclick = () => {
                    cancelCallback();
                    confirmationModal.hide();
                };
            } else {
                cancelButton.onclick = () => {
                    confirmationModal.hide();
                };
            }
            confirmationModal.show();
        }

        // Copy Firebase User ID to clipboard
        copyFirebaseUserIdBtn.addEventListener('click', () => {
            const idToCopy = firebaseUserIdDisplay.textContent;
            try {
                const textArea = document.createElement("textarea");
                textArea.value = idToCopy;
                textArea.style.position = "fixed";
                textArea.style.left = "-9999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showSuccess("Firebase User ID copied to clipboard!");
            } catch (err) {
                console.error('Failed to copy:', err);
                showError("Failed to copy Firebase User ID.");
            }
        });


        // Show page function
        function showPage(pageId) {
            if (!loggedInUser && pageId !== 'loginPage' && pageId !== 'infoPage') {
                showError('Please login to access this page.');
                showPage('loginPage');
                return;
            }
            // Specific logic for Due Collect page to show initial message
            if (pageId === 'dueCollectPage') {
                document.getElementById('dueCollectTableContainer').innerHTML = '<p class="text-center text-muted p-3">Select a source (Due List or Incoming Funds) to start collecting.</p>';
            }

            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById(pageId).classList.add('active');
        }

        // Login/Logout Functions
        function checkLoginStatus() {
            const storedUser = localStorage.getItem('loggedInUser');
            console.log("checkLoginStatus called. Stored 'loggedInUser':", storedUser);

            if (storedUser) {
                // Ensure the custom loggedInUser still exists in the fetched loginUsers from Firebase
                const userExists = loginUsers.some(user => String(user.username) === String(storedUser));
                console.log(`Stored user "${storedUser}" exists in loginUsers array (from Firebase):`, userExists);

                if (userExists) {
                    loggedInUser = storedUser;
                    localStorage.setItem('loggedInUser', username); // Store custom username in localStorage
                    document.getElementById('currentUsername').textContent = loggedInUser;
                    document.getElementById('loggedInUserDisplay').style.display = 'flex';
                    document.getElementById('mainNavButtons').style.display = 'block';
                    showPage('dueListPage'); // Redirect to a default page after login
                } else {
                    // Stored user does not exist in the current loginUsers array (e.g., deleted from Firebase)
                    console.warn(`Stored user "${storedUser}" not found in current loginUsers array. Forcing logout.`);
                    logout(false); // Force logout without confirmation
                    showError('Previous session data is invalid. Please log in again.');
                }
            } else {
                loggedInUser = null; // Ensure loggedInUser is null if no stored user
                console.log("No 'loggedInUser' found in localStorage. Displaying login page.");
                showPage('loginPage');
                document.getElementById('loggedInUserDisplay').style.display = 'none';
                document.getElementById('mainNavButtons').style.display = 'none';
            }
        }

        async function login(e) {
            e.preventDefault();
            const username = document.getElementById('usernameInput').value.trim();
            const password = document.getElementById('passwordInput').value.trim();
            const loginErrorDiv = document.getElementById('loginError');

            // Find user in Firestore-backed loginUsers
            const userFound = loginUsers.find(user => user.username === username && user.password === password);

            if (userFound) {
                loggedInUser = username;
                localStorage.setItem('loggedInUser', username); // Store custom username in localStorage
                document.getElementById('currentUsername').textContent = loggedInUser;
                document.getElementById('loggedInUserDisplay').style.display = 'flex';
                document.getElementById('mainNavButtons').style.display = 'block';
                loginErrorDiv.style.display = 'none';
                showSuccess('Logged in successfully!');
                showPage('dueListPage'); // Default page after login
            } else {
                loggedInUser = null;
                localStorage.removeItem('loggedInUser');
                loginErrorDiv.textContent = 'Invalid username or password. Please try again.';
                loginErrorDiv.style.display = 'block';
            }
        }

        function logout(confirm = true) {
            const performLogout = () => {
                loggedInUser = null;
                localStorage.removeItem('loggedInUser');
                showSuccess('Logged out successfully!');
                checkLoginStatus(); // Redirects to login page
            };

            if (confirm) {
                showConfirmation('Are you sure you want to log out?', performLogout);
            } else {
                performLogout();
            }
        }

        // Generate unique receipt number (now relies on Firebase counter)
        async function generateReceiptNumber() {
            if (!isAuthReady || !firebaseUserId) {
                showError("Firebase is not ready, cannot generate receipt number.");
                return null;
            }
            const receiptCounterDocRef = doc(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/metadata/receiptCounter`);
            try {
                // Use a transaction to safely increment the counter
                const docSnap = await getDoc(receiptCounterDocRef);
                let currentCounter = 0;
                if (docSnap.exists()) {
                    currentCounter = docSnap.data().counter || 0;
                }
                const newCounter = currentCounter + 1;
                await updateDoc(receiptCounterDocRef, { counter: newCounter });
                receiptCounter = newCounter; // Update local counter

                const date = new Date();
                const year = date.getFullYear().toString().slice(-2);
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const day = date.getDate().toString().padStart(2, '0');
                const hour = date.getHours().toString().padStart(2, '0');
                const minute = date.getMinutes().toString().padStart(2, '0');
                const second = date.getSeconds().toString().padStart(2, '0');
                return `RC-${year}${month}${day}-${hour}${minute}${second}-${newCounter}`;
            } catch (error) {
                console.error("Error generating receipt number:", error);
                showError("Failed to generate receipt number.");
                return null;
            }
        }

        // Helper to clean purpose string from (Collected: X) tags
        function cleanPurpose(purpose) {
            let cleaned = purpose;
            const regex = /\s*\(Collected:\s*[^)]+\)/g; // Regex to match (Collected: ...)
            cleaned = cleaned.replace(regex, '').trim();
            return cleaned;
        }

        // Populate name dropdowns in entry forms & filters (uses dropdownNames from Firebase)
        function populateNameDropdowns() {
            const dueNameSelect = document.getElementById('dueName');
            const incomingNameSelect = document.getElementById('incomingName');
            const dueFilter = document.getElementById('dueFilterName');
            const incomingFilter = document.getElementById('incomingFilterName');

            [dueNameSelect, incomingNameSelect, dueFilter, incomingFilter].forEach(select => {
                let currentValue = select.value; // Store current value before clearing
                select.innerHTML = ''; // Clear existing options

                if (select === dueFilter || select === incomingFilter) {
                    select.innerHTML += '<option value="all">All</option>';
                } else {
                    select.innerHTML += '<option value="" disabled selected>Select Name</option>';
                }

                dropdownNames.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    select.appendChild(option);
                });

                // Re-select the appropriate value based on stored filter state or previous selection
                if (select === dueFilter) {
                    select.value = currentDueFilter;
                } else if (select === incomingFilter) {
                    select.value = currentIncomingFilter;
                } else if (dropdownNames.includes(currentValue)) {
                    select.value = currentValue;
                } else {
                    select.value = "";
                }
            });
        }

        // ------------ Due List Functions ------------

        // Render Due List table
        function renderDueList(dataToRender = null) {
            const tbody = document.querySelector('#dueTable tbody');
            tbody.innerHTML = '';

            let displayedData = dataToRender;
            if (displayedData === null) {
                displayedData = currentDueFilter === 'all' ? dueEntries : dueEntries.filter(e => String(e.name) === String(currentDueFilter));
            }

            // Apply search term if present (always on the current filtered data)
            const searchTerm = document.getElementById('dueSearchInput')?.value?.toLowerCase().trim() || '';
            if (searchTerm !== '') {
                displayedData = displayedData.filter(entry => {
                    const nameMatch = entry.name?.toLowerCase().includes(searchTerm);
                    const purposeMatch = entry.purpose?.toLowerCase().includes(searchTerm);
                    const amountMatch = String(entry.amount)?.toLowerCase().includes(searchTerm);
                    const dateMatch = entry.date?.toLowerCase().includes(searchTerm);
                    return nameMatch || purposeMatch || amountMatch || dateMatch;
                });
            }

            if (displayedData.length === 0 && searchTerm === '') {
                tbody.innerHTML = '<tr><td colspan="7" class="text-center text-muted">No Due Entries.</td></tr>';
            } else if (displayedData.length === 0 && searchTerm !== '') {
                 tbody.innerHTML = '<tr><td colspan="7" class="text-center text-muted">No matching results found.</td></tr>';
            }

            displayedData.forEach((entry, index) => {
                const tr = document.createElement('tr');
                const nameCell = entry.isEditing ? `<select class="form-select" id="editDueName-${entry.id}">${getDropdownNamesOptions(entry.name)}</select>` : `<span>${entry.name}</span>`;
                const purposeCell = entry.isEditing ? `<input type="text" class="form-control" value="${entry.purpose || ''}" id="editDuePurpose-${entry.id}" />` : `<span>${entry.purpose}</span>`;
                const amountCell = entry.isEditing ? `<input type="number" class="form-control" value="${entry.amount}" min="0" step="any" id="editDueAmount-${entry.id}" />` : `<span>${entry.amount}</span>`;
                const dateCell = entry.isEditing ? `<input type="date" class="form-control" value="${entry.date || ''}" id="editDueDate-${entry.id}" />` : `<span>${entry.date}</span>`;
                const statusCell = `
                    <select class="form-select" id="editDueStatus-${entry.id}" onchange="updateDueEntryStatusFromSelect('${entry.id}', this.value)" ${entry.isEditing ? '' : 'disabled'}>
                        <option value="Due" ${entry.status === 'Due' ? 'selected' : ''}>Due</option>
                        <option value="Paid" ${entry.status === 'Paid' ? 'selected' : ''}>Paid</option>
                    </select>
                `;

                tr.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${nameCell}</td>
                    <td>${purposeCell}</td>
                    <td>${amountCell}</td>
                    <td>${dateCell}</td>
                    <td>${statusCell}</td>
                    <td>
                        ${entry.isEditing ? `
                            <button class="btn btn-success btn-sm me-1" onclick="updateDueEntry('${entry.id}')">Update</button>
                            <button class="btn btn-secondary btn-sm" onclick="cancelDueEdit('${entry.id}')">Cancel</button>
                        ` : `
                            <button class="btn btn-warning btn-sm me-1" onclick="editDueEntry('${entry.id}')">Edit</button>
                            <button class="btn btn-danger btn-sm" onclick="deleteDueEntry('${entry.id}')">Delete</button>
                        `}
                    </td>
                `;
                tbody.appendChild(tr);
            });

            updateDueTotal(displayedData);
        }

        // Helper to generate options for name dropdown in edit mode (uses dropdownNames)
        function getDropdownNamesOptions(selectedName) {
            let options = '';
            dropdownNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                if (String(name) === String(selectedName)) {
                    option.selected = true;
                }
                options += option.outerHTML;
            });
            return options;
        }

        // Add Due Entry to Firebase
        async function addDueEntry(e) {
            e.preventDefault();

            if (!isAuthReady || !firebaseUserId) {
                showError("Firebase is not ready. Please wait.");
                return;
            }
            if (!loggedInUser) {
                showError("Please login before adding an entry.");
                return;
            }

            const dueDate = document.getElementById('dueDate').value.trim();
            const taskName = document.getElementById('duePurpose').value.trim(); // Renamed 'purpose' to 'taskName' in original HTML, but variable is duePurpose
            const amount = document.getElementById('dueAmount').value.trim();
            const name = document.getElementById('dueName').value; // 'name' from dropdown

            if (!name || !taskName || !amount || !dueDate) {
                showError('Please fill all required fields.');
                return;
            }

            try {
                await addDoc(collection(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/dueEntries`), {
                    name: name,
                    purpose: taskName,
                    amount: Number(amount),
                    date: dueDate,
                    status: 'Due',
                    category: 'Due List',
                    createdAt: new Date().toISOString(), // Add timestamp for ordering
                    originalAmount: Number(amount) // Store original amount for partial collection
                });
                document.getElementById('dueEntryForm').reset();
                showSuccess('Due entry added successfully!');
            } catch (e) {
                console.error("Error adding due entry: ", e);
                showError("Error adding due entry. Please try again.");
            }
        }

        // Edit Due Entry (sets editing mode)
        function editDueEntry(entryId) {
            dueEntries = dueEntries.map(entry => {
                if (entry.id === entryId) {
                    return { ...entry, isEditing: true };
                }
                return { ...entry, isEditing: false }; // Ensure only one entry is in editing mode
            });
            renderDueList();
        }

        // Cancel Due Edit
        function cancelDueEdit(entryId) {
            dueEntries = dueEntries.map(entry => {
                if (entry.id === entryId) {
                    return { ...entry, isEditing: false };
                }
                return entry;
            });
            renderDueList();
        }

        // Update Due Entry (saves changes to Firebase)
        async function updateDueEntry(entryId) {
            if (!isAuthReady || !firebaseUserId) {
                showError("Firebase is not ready. Please wait.");
                return;
            }

            const entryRef = doc(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/dueEntries`, entryId);
            const newName = document.getElementById(`editDueName-${entryId}`).value;
            const newPurpose = document.getElementById(`editDuePurpose-${entryId}`).value.trim();
            const newAmount = Number(document.getElementById(`editDueAmount-${entryId}`).value);
            const newDate = document.getElementById(`editDueDate-${entryId}`).value;
            const newStatus = document.getElementById(`editDueStatus-${entryId}`).value;

            if (!newName || !newPurpose || isNaN(newAmount) || newAmount < 0 || !newDate) {
                showError('Please fill all required fields for update.');
                return;
            }

            const currentEntry = dueEntries.find(e => e.id === entryId);
            if (!currentEntry) {
                showError("Entry not found!");
                return;
            }

            if (newStatus === 'Paid') {
                showConfirmation(`Marking this entry as PAID will move it to Paid Report. Are you sure?`, async () => {
                    try {
                        const paidRecord = {
                            sourceEntryId: entryId, // Reference to original due entry
                            name: newName,
                            purpose: newPurpose,
                            amount: newAmount,
                            date: new Date().toISOString().split('T')[0], // Date of collection
                            status: 'Paid',
                            category: 'Due List',
                            receiptNumber: await generateReceiptNumber(), // Generate new receipt
                            createdAt: new Date().toISOString()
                        };
                        await addDoc(collection(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/paidEntries`), paidRecord);
                        await deleteDoc(entryRef); // Remove from due list
                        showSuccess('Entry successfully paid and moved to Paid Report.');
                    } catch (error) {
                        console.error("Error updating or paying due entry:", error);
                        showError("Error updating or paying entry. Please try again.");
                    }
                }, () => {
                    // Revert UI if cancelled
                    cancelDueEdit(entryId);
                    showError('Operation cancelled.');
                });
            } else {
                try {
                    await updateDoc(entryRef, {
                        name: newName,
                        purpose: newPurpose,
                        amount: newAmount,
                        date: newDate,
                        status: newStatus,
                        isEditing: false // Turn off editing mode
                    });
                    showSuccess('Entry successfully updated.');
                } catch (error) {
                    console.error("Error updating due entry:", error);
                    showError("Error updating entry. Please try again.");
                }
            }
        }

        // Function called directly by status select dropdown in Due List table
        async function updateDueEntryStatusFromSelect(entryId, value) {
            if (!isAuthReady || !firebaseUserId) {
                showError("Firebase is not ready. Please wait.");
                return;
            }
            const entryRef = doc(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/dueEntries`, entryId);
            const currentEntry = dueEntries.find(e => e.id === entryId);

            if (!currentEntry) {
                showError("Entry not found!");
                return;
            }

            if (value === 'Paid') {
                showConfirmation(`Marking this entry as PAID will move it to Paid Report. Are you sure?`, async () => {
                    try {
                        const paidRecord = {
                            sourceEntryId: entryId,
                            name: currentEntry.name,
                            purpose: currentEntry.purpose,
                            amount: currentEntry.amount,
                            date: new Date().toISOString().split('T')[0],
                            status: 'Paid',
                            category: 'Due List',
                            receiptNumber: await generateReceiptNumber(),
                            createdAt: new Date().toISOString()
                        };
                        await addDoc(collection(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/paidEntries`), paidRecord);
                        await deleteDoc(entryRef);
                        showSuccess('Entry successfully paid and moved to Paid Report.');
                    }
                    catch (error) {
                        console.error("Error updating or paying due entry:", error);
                        showError("Error updating or paying entry. Please try again.");
                    }
                }, () => {
                    // Revert UI selection if cancelled
                    renderDueList(); // Re-render to show original status
                    showError('Operation cancelled.');
                });
            } else {
                // Should not happen for 'Due' list where default is 'Due'
                try {
                    await updateDoc(entryRef, { status: value });
                    showSuccess('Entry status successfully updated.');
                }
                catch (error) {
                    console.error("Error updating due entry status:", error);
                    showError("Error updating entry status. Please try again.");
                }
            }
        }


        // Delete Due Entry from Firebase
        function deleteDueEntry(entryId) {
            if (!isAuthReady || !firebaseUserId) {
                showError("Firebase is not ready. Please wait.");
                return;
            }
            showConfirmation('Are you sure you want to delete this entry?', async () => {
                try {
                    await deleteDoc(doc(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/dueEntries`, entryId));
                    showSuccess('Entry successfully deleted!');
                }
                catch (error) {
                    console.error("Error deleting due entry: ", error);
                    showError("Error deleting entry. Please try again.");
                }
            });
        }

        // Filter Due List by Name
        function filterDueList() {
            currentDueFilter = document.getElementById('dueFilterName').value;
            document.getElementById('dueSearchInput').value = '';
            renderDueList();
        }

        // Search Due List
        function searchDueList() {
            // Filter is applied during renderDueList by checking the search input value.
            // No need to pass filtered data here, just re-render.
            document.getElementById('dueFilterName').value = 'all'; // Clear filter when searching
            currentDueFilter = 'all';
            renderDueList();
        }

        // Update Due Total Amount
        function updateDueTotal(entries) {
            let total = 0;
            entries.forEach(e => {
                if (e.status === 'Due') {
                    total += e.amount;
                }
            });
            document.getElementById('dueTotalAmount').textContent = total.toFixed(2);
        }

        // Export Due List PDF (uses currently rendered data)
        function exportDuePDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            // Get currently displayed data from render function's internal filtering logic
            let dataToExport = currentDueFilter === 'all' ? [...dueEntries] : dueEntries.filter(e => String(e.name) === String(currentDueFilter));

            const searchTerm = document.getElementById('dueSearchInput')?.value?.toLowerCase().trim() || '';
            if (searchTerm !== '') {
                dataToExport = dataToExport.filter(entry => {
                    const nameMatch = entry.name?.toLowerCase().includes(searchTerm);
                    const purposeMatch = entry.purpose?.toLowerCase().includes(searchTerm);
                    const amountMatch = String(entry.amount)?.toLowerCase().includes(searchTerm);
                    const dateMatch = entry.date?.toLowerCase().includes(searchTerm);
                    return nameMatch || purposeMatch || amountMatch || dateMatch;
                });
            }

            doc.text('Due List Report', 14, 15);
            doc.autoTable({
                startY: 20,
                head: [['Serial', 'Name', 'Purpose', 'Amount', 'Date', 'Status']],
                body: dataToExport.map((e, i) => [i + 1, e.name, e.purpose, e.amount, e.date, e.status])
            });
            doc.save('due_list_report.pdf');
            showSuccess('Due List exported as PDF');
        }

        // Export Due List Excel (uses currently rendered data)
        function exportDueExcel() {
            const wb = XLSX.utils.book_new();
            // Get currently displayed data from render function's internal filtering logic
            let dataToExport = currentDueFilter === 'all' ? [...dueEntries] : dueEntries.filter(e => String(e.name) === String(currentDueFilter));

            const searchTerm = document.getElementById('dueSearchInput')?.value?.toLowerCase().trim() || '';
            if (searchTerm !== '') {
                dataToExport = dataToExport.filter(entry => {
                    const nameMatch = entry.name?.toLowerCase().includes(searchTerm);
                    const purposeMatch = entry.purpose?.toLowerCase().includes(searchTerm);
                    const amountMatch = String(entry.amount)?.toLowerCase().includes(searchTerm);
                    const dateMatch = entry.date?.toLowerCase().includes(searchTerm);
                    return nameMatch || purposeMatch || amountMatch || dateMatch;
                });
            }

            const wsData = [
                ['Serial', 'Name', 'Purpose', 'Amount', 'Date', 'Status'],
                ...dataToExport.map((e, i) => [i + 1, e.name, e.purpose, e.amount, e.date, e.status])
            ];
            const ws = XLSX.utils.aoa_to_sheet(wsData);
            XLSX.utils.book_append_sheet(wb, ws, 'Due List Report');
            XLSX.writeFile(wb, 'due_list_report.xlsx');
            showSuccess('Due List exported as Excel');
        }


        // ------------ Incoming Funds Functions ------------

        function renderIncomingList(dataToRender = null) {
            const tbody = document.querySelector('#incomingTable tbody');
            tbody.innerHTML = '';

            let displayedData = dataToRender;
            if (displayedData === null) {
                displayedData = currentIncomingFilter === 'all' ? incomingEntries : incomingEntries.filter(e => String(e.name) === String(currentIncomingFilter));
            }

            // Apply search term if present
            const searchTerm = document.getElementById('incomingSearchInput')?.value?.toLowerCase().trim() || '';
            if (searchTerm !== '') {
                displayedData = displayedData.filter(entry => {
                    const nameMatch = entry.name?.toLowerCase().includes(searchTerm);
                    const purposeMatch = entry.purpose?.toLowerCase().includes(searchTerm);
                    const amountMatch = String(entry.amount)?.toLowerCase().includes(searchTerm);
                    const dateMatch = entry.date?.toLowerCase().includes(searchTerm);
                    return nameMatch || purposeMatch || amountMatch || dateMatch;
                });
            }

            if (displayedData.length === 0 && searchTerm === '') {
                tbody.innerHTML = '<tr><td colspan="7" class="text-center text-muted">No Incoming Entries.</td></tr>';
            } else if (displayedData.length === 0 && searchTerm !== '') {
                tbody.innerHTML = '<tr><td colspan="7" class="text-center text-muted">No matching results found.</td></tr>';
            }

            displayedData.forEach((entry, index) => {
                const tr = document.createElement('tr');
                const nameCell = entry.isEditing ? `<select class="form-select" id="editIncomingName-${entry.id}">${getDropdownNamesOptions(entry.name)}</select>` : `<span>${entry.name}</span>`;
                const purposeCell = entry.isEditing ? `<input type="text" class="form-control" value="${entry.purpose || ''}" id="editIncomingPurpose-${entry.id}" />` : `<span>${entry.purpose}</span>`;
                const amountCell = entry.isEditing ? `<input type="number" class="form-control" value="${entry.amount}" min="0" step="any" id="editIncomingAmount-${entry.id}" />` : `<span>${entry.amount}</span>`;
                const dateCell = entry.isEditing ? `<input type="date" class="form-control" value="${entry.date || ''}" id="editIncomingDate-${entry.id}" />` : `<span>${entry.date}</span>`;
                const statusCell = `
                    <select class="form-select" id="editIncomingStatus-${entry.id}" onchange="updateIncomingEntryStatusFromSelect('${entry.id}', this.value)" ${entry.isEditing ? '' : 'disabled'}>
                        <option value="Due" ${entry.status === 'Due' ? 'selected' : ''}>Due</option>
                        <option value="Paid" ${entry.status === 'Paid' ? 'selected' : ''}>Paid</option>
                    </select>
                `;

                tr.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${nameCell}</td>
                    <td>${purposeCell}</td>
                    <td>${amountCell}</td>
                    <td>${dateCell}</td>
                    <td>${statusCell}</td>
                    <td>
                        ${entry.isEditing ? `
                            <button class="btn btn-success btn-sm me-1" onclick="updateIncomingEntry('${entry.id}')">Update</button>
                            <button class="btn btn-secondary btn-sm" onclick="cancelIncomingEdit('${entry.id}')">Cancel</button>
                        ` : `
                            <button class="btn btn-warning btn-sm me-1" onclick="editIncomingEntry('${entry.id}')">Edit</button>
                            <button class="btn btn-danger btn-sm" onclick="deleteIncomingEntry('${entry.id}')">Delete</button>
                        `}
                    </td>
                `;
                tbody.appendChild(tr);
            });

            updateIncomingTotal(displayedData);
        }

        // Add Incoming Entry to Firebase
        async function addIncomingEntry(e) {
            e.preventDefault();

            if (!isAuthReady || !firebaseUserId) {
                showError("Firebase is not ready. Please wait.");
                return;
            }
            if (!loggedInUser) {
                showError("Please login before adding an entry.");
                return;
            }

            const name = document.getElementById('incomingName').value;
            const purpose = document.getElementById('incomingPurpose').value.trim();
            const amount = document.getElementById('incomingAmount').value.trim();
            const date = document.getElementById('incomingDate').value;

            if (!name || !purpose || !amount || !date) {
                showError('Please fill all required fields.');
                return;
            }

            try {
                await addDoc(collection(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/incomingEntries`), {
                    name: name,
                    purpose: purpose,
                    amount: Number(amount),
                    date: date,
                    status: 'Due',
                    category: 'Incoming Funds',
                    createdAt: new Date().toISOString(),
                    originalAmount: Number(amount)
                });
                document.getElementById('incomingEntryForm').reset();
                showSuccess('Incoming entry added successfully!');
            }
            catch (e) {
                console.error("Error adding incoming entry: ", e);
                showError("Error adding incoming entry. Please try again.");
            }
        }

        // Edit Incoming Entry (sets editing mode)
        function editIncomingEntry(entryId) {
            incomingEntries = incomingEntries.map(entry => {
                if (entry.id === entryId) {
                    return { ...entry, isEditing: true };
                }
                return { ...entry, isEditing: false };
            });
            renderIncomingList();
        }

        // Cancel Incoming Edit
        function cancelIncomingEdit(entryId) {
            incomingEntries = incomingEntries.map(entry => {
                if (entry.id === entryId) {
                    return { ...entry, isEditing: false };
                }
                return entry;
            });
            renderIncomingList();
        }

        // Update Incoming Entry (saves changes to Firebase)
        async function updateIncomingEntry(entryId) {
            if (!isAuthReady || !firebaseUserId) {
                showError("Firebase is not ready. Please wait.");
                return;
            }

            const entryRef = doc(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/incomingEntries`, entryId);
            const newName = document.getElementById(`editIncomingName-${entryId}`).value;
            const newPurpose = document.getElementById(`editIncomingPurpose-${entryId}`).value.trim();
            const newAmount = Number(document.getElementById(`editIncomingAmount-${entryId}`).value);
            const newDate = document.getElementById(`editIncomingDate-${entryId}`).value;
            const newStatus = document.getElementById(`editIncomingStatus-${entryId}`).value;

            if (!newName || !newPurpose || isNaN(newAmount) || newAmount < 0 || !newDate) {
                showError('Please fill all required fields for update.');
                return;
            }

            const currentEntry = incomingEntries.find(e => e.id === entryId);
            if (!currentEntry) {
                showError("Entry not found!");
                return;
            }

            if (newStatus === 'Paid') {
                showConfirmation(`Marking this entry as PAID will move it to Paid Report. Are you sure?`, async () => {
                    try {
                        const paidRecord = {
                            sourceEntryId: entryId,
                            name: newName,
                            purpose: newPurpose,
                            amount: newAmount,
                            date: new Date().toISOString().split('T')[0],
                            status: 'Paid',
                            category: 'Incoming Funds',
                            receiptNumber: await generateReceiptNumber(),
                            createdAt: new Date().toISOString()
                        };
                        await addDoc(collection(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/paidEntries`), paidRecord);
                        await deleteDoc(entryRef);
                        showSuccess('Entry successfully paid and moved to Paid Report.');
                    }
                    catch (error) {
                        console.error("Error updating or paying incoming entry:", error);
                        showError("Error updating or paying entry. Please try again.");
                    }
                }, () => {
                    cancelIncomingEdit(entryId);
                    showError('Operation cancelled.');
                });
            } else {
                try {
                    await updateDoc(entryRef, {
                        name: newName,
                        purpose: newPurpose,
                        amount: newAmount,
                        date: newDate,
                        status: newStatus,
                        isEditing: false
                    });
                    showSuccess('Entry successfully updated.');
                }
                catch (error) {
                    console.error("Error updating incoming entry:", error);
                    showError("Error updating entry. Please try again.");
                }
            }
        }

        // Function called directly by status select dropdown in Incoming Funds table
        async function updateIncomingEntryStatusFromSelect(entryId, value) {
            if (!isAuthReady || !firebaseUserId) {
                showError("Firebase is not ready. Please wait.");
                return;
            }
            const entryRef = doc(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/incomingEntries`, entryId);
            const currentEntry = incomingEntries.find(e => e.id === entryId);

            if (!currentEntry) {
                showError("Entry not found!");
                return;
            }

            if (value === 'Paid') {
                showConfirmation(`Marking this entry as PAID will move it to Paid Report. Are you sure?`, async () => {
                    try {
                        const paidRecord = {
                            sourceEntryId: entryId,
                            name: currentEntry.name,
                            purpose: currentEntry.purpose,
                            amount: currentEntry.amount,
                            date: new Date().toISOString().split('T')[0],
                            status: 'Paid',
                            category: 'Incoming Funds',
                            receiptNumber: await generateReceiptNumber(),
                            createdAt: new Date().toISOString()
                        };
                        await addDoc(collection(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/paidEntries`), paidRecord);
                        await deleteDoc(entryRef);
                        showSuccess('Entry successfully paid and moved to Paid Report.');
                    }
                    catch (error) {
                        console.error("Error updating or paying incoming entry:", error);
                        showError("Error updating or paying entry. Please try again.");
                    }
                }, () => {
                    renderIncomingList();
                    showError('Operation cancelled.');
                });
            } else {
                try {
                    await updateDoc(entryRef, { status: value });
                    showSuccess('Entry status successfully updated.');
                }
                catch (error) {
                    console.error("Error updating incoming entry status:", error);
                    showError("Error updating entry status. Please try again.");
                }
            }
        }

        // Delete Incoming Entry from Firebase
        function deleteIncomingEntry(entryId) {
            if (!isAuthReady || !firebaseUserId) {
                showError("Firebase is not ready. Please wait.");
                return;
            }
            showConfirmation('Are you sure you want to delete this entry?', async () => {
                try {
                    await deleteDoc(doc(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/incomingEntries`, entryId));
                    showSuccess('Entry successfully deleted!');
                }
                catch (error) {
                    console.error("Error deleting incoming entry: ", error);
                    showError("Error deleting entry. Please try again.");
                }
            });
        }

        // Filter Incoming List by Name
        function filterIncomingList() {
            currentIncomingFilter = document.getElementById('incomingFilterName').value;
            document.getElementById('incomingSearchInput').value = '';
            renderIncomingList();
        }

        // Search Incoming List
        function searchIncomingList() {
            document.getElementById('incomingFilterName').value = 'all';
            currentIncomingFilter = 'all';
            renderIncomingList();
        }

        // Update Incoming Total Amount
        function updateIncomingTotal(entries) {
            let total = 0;
            entries.forEach(e => {
                if (e.status === 'Due') {
                    total += e.amount;
                }
            });
            document.getElementById('incomingTotalAmount').textContent = total.toFixed(2);
        }

        // Export Incoming Funds PDF
        function exportIncomingPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            let dataToExport = currentIncomingFilter === 'all' ? [...incomingEntries] : incomingEntries.filter(e => String(e.name) === String(currentIncomingFilter));

            const searchTerm = document.getElementById('incomingSearchInput')?.value?.toLowerCase().trim() || '';
            if (searchTerm !== '') {
                dataToExport = dataToExport.filter(entry => {
                    const nameMatch = entry.name?.toLowerCase().includes(searchTerm);
                    const purposeMatch = entry.purpose?.toLowerCase().includes(searchTerm);
                    const amountMatch = String(entry.amount)?.toLowerCase().includes(searchTerm);
                    const dateMatch = entry.date?.toLowerCase().includes(searchTerm);
                    return nameMatch || purposeMatch || amountMatch || dateMatch;
                });
            }

            doc.text('Incoming Funds Report', 14, 15);
            doc.autoTable({
                startY: 20,
                head: [['Serial', 'Name', 'Purpose', 'Amount', 'Date', 'Status']],
                body: dataToExport.map((e, i) => [i + 1, e.name, e.purpose, e.amount, e.date, e.status])
            });
            doc.save('incoming_funds_report.pdf');
            showSuccess('Incoming Funds exported as PDF');
        }

        // Export Incoming Funds Excel
        function exportIncomingExcel() {
            const wb = XLSX.utils.book_new();
            let dataToExport = currentIncomingFilter === 'all' ? [...incomingEntries] : incomingEntries.filter(e => String(e.name) === String(currentIncomingFilter));

            const searchTerm = document.getElementById('incomingSearchInput')?.value?.toLowerCase().trim() || '';
            if (searchTerm !== '') {
                dataToExport = dataToExport.filter(entry => {
                    const nameMatch = entry.name?.toLowerCase().includes(searchTerm);
                    const purposeMatch = entry.purpose?.toLowerCase().includes(searchTerm);
                    const amountMatch = String(entry.amount)?.toLowerCase().includes(searchTerm);
                    const dateMatch = entry.date?.toLowerCase().includes(searchTerm);
                    return nameMatch || purposeMatch || amountMatch || dateMatch;
                });
            }

            const wsData = [
                ['Serial', 'Name', 'Purpose', 'Amount', 'Date', 'Status'],
                ...dataToExport.map((e, i) => [i + 1, e.name, e.purpose, e.amount, e.date, e.status])
            ];
            const ws = XLSX.utils.aoa_to_sheet(wsData);
            XLSX.utils.book_append_sheet(wb, ws, 'Incoming Funds Report');
            XLSX.writeFile(wb, 'incoming_funds_report.xlsx');
            showSuccess('Incoming Funds exported as Excel');
        }

        // ------------ Due Collect Functions ------------

        function displayCollectionTable(source) {
            const container = document.getElementById('dueCollectTableContainer');
            container.innerHTML = '';

            let dataToDisplay = [];
            let tableId = '';
            let headerText = '';
            let tableClass = '';

            if (source === 'due') {
                dataToDisplay = dueEntries.filter(entry => entry.status === 'Due');
                tableId = 'dueCollectDueTable';
                headerText = 'Due List for Collection';
                tableClass = 'table-primary';
            } else if (source === 'incoming') {
                dataToDisplay = incomingEntries.filter(entry => entry.status === 'Due');
                tableId = 'dueCollectIncomingTable';
                headerText = 'Incoming Funds for Collection';
                tableClass = 'table-success';
            } else {
                container.innerHTML = '<p class="text-center text-muted p-3">Invalid source selected.</p>';
                return;
            }

            if (dataToDisplay.length === 0) {
                container.innerHTML = `<p class="text-center text-muted p-3">No pending entries in ${headerText.replace(' for Collection', '')}.</p>`;
                return;
            }

            const tableHTML = `
                <h5>${headerText}</h5>
                <table id="${tableId}" class="table table-bordered table-striped align-middle">
                    <thead class="${tableClass}">
                        <tr>
                            <th>Serial</th>
                            <th>Name</th>
                            <th>Purpose</th>
                            <th>Original Amount</th>
                            <th>Current Due</th>
                            <th>Collection Date</th>
                            <th>Collect Amount</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${dataToDisplay.map((entry, index) => `
                            <tr>
                                <td>${index + 1}</td>
                                <td>${entry.name}</td>
                                <td>${entry.purpose}</td>
                                <td>${entry.originalAmount ? entry.originalAmount.toFixed(2) : entry.amount.toFixed(2)}</td>
                                <td>${entry.amount.toFixed(2)}</td>
                                <td>
                                    <input type="date" class="form-control form-control-sm" id="collectDate-${source}-${entry.id}" value="${new Date().toISOString().split('T')[0]}">
                                </td>
                                <td>
                                    <input type="number" class="form-control form-control-sm" id="collectAmount-${source}-${entry.id}" value="${entry.amount.toFixed(2)}" min="0" step="any" max="${entry.amount.toFixed(2)}">
                                </td>
                                <td>
                                    <button class="btn btn-info btn-sm" onclick="collectAmount('${source}', '${entry.id}')">Collect</button>
                                </td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
            container.innerHTML = tableHTML;
        }

        async function collectAmount(source, entryId) {
            if (!isAuthReady || !firebaseUserId) {
                showError("Firebase is not ready. Please wait.");
                return;
            }

            const collectAmountInput = document.getElementById(`collectAmount-${source}-${entryId}`);
            const collectDateInput = document.getElementById(`collectDate-${source}-${entryId}`);

            if (!collectAmountInput || !collectDateInput) {
                showError('Collection input fields not found.');
                return;
            }

            let collectedAmount = Number(collectAmountInput.value);
            const collectionDate = collectDateInput.value;

            if (isNaN(collectedAmount) || collectedAmount <= 0) {
                showError('Please enter a valid amount to collect.');
                return;
            }

            let entry;
            let collectionPath;
            if (source === 'due') {
                entry = dueEntries.find(e => e.id === entryId);
                collectionPath = `artifacts/${appIdEnv}/users/${firebaseUserId}/dueEntries`;
            } else if (source === 'incoming') {
                entry = incomingEntries.find(e => e.id === entryId);
                collectionPath = `artifacts/${appIdEnv}/users/${firebaseUserId}/incomingEntries`;
            }

            if (!entry) {
                showError('Entry not found for collection! Please refresh and try again.');
                return;
            }

            if (collectedAmount > entry.amount) {
                collectedAmount = entry.amount;
                collectAmountInput.value = collectedAmount.toFixed(2);
                showError(`Collected amount cannot exceed current due. Adjusted to ${collectedAmount.toFixed(2)}.`);
            }

            showConfirmation(`Collect ${collectedAmount.toFixed(2)} from ${entry.name} (${entry.purpose})?`, async () => {
                const remainingAmount = entry.amount - collectedAmount;
                const batch = writeBatch(db);

                const paidRecord = {
                    sourceEntryId: entry.id,
                    name: entry.name,
                    purpose: `${cleanPurpose(entry.purpose)} (Collected: ${collectedAmount.toFixed(2)})`,
                    amount: collectedAmount,
                    date: collectionDate,
                    status: 'Paid',
                    category: entry.category,
                    receiptNumber: await generateReceiptNumber(),
                    createdAt: new Date().toISOString()
                };
                const newPaidDocRef = doc(collection(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/paidEntries`));
                batch.set(newPaidDocRef, paidRecord);

                const originalEntryRef = doc(db, collectionPath, entryId);

                if (remainingAmount <= 0.01) { // Fully paid
                    batch.delete(originalEntryRef);
                    showSuccess('Amount fully collected and entry moved to Paid Report.');
                } else { // Partially paid
                    batch.update(originalEntryRef, { amount: remainingAmount });
                    showSuccess(`Amount collected. Remaining due for ${entry.name}: ${remainingAmount.toFixed(2)}.`);
                }

                try {
                    await batch.commit();
                    displayCollectionTable(source); // Re-render the collection table
                }
                catch (error) {
                    console.error("Error collecting amount:", error);
                    showError("Error collecting amount. Please try again.");
                }
            });
        }


        // ------------ Paid Report Functions ------------

        // Render Paid Report table
        function renderPaidReport(dataToRender = null) {
            const tbody = document.querySelector('#paidTable tbody');
            tbody.innerHTML = '';

            let displayedData = dataToRender;
            if (displayedData === null) {
                displayedData = currentPaidFilterCategory === 'all' ? paidEntries : paidEntries.filter(e => String(e.category) === String(currentPaidFilterCategory));
            }

            // Apply search term if present
            const searchTerm = document.getElementById('paidSearchInput')?.value?.toLowerCase().trim() || '';
            if (searchTerm !== '') {
                displayedData = displayedData.filter(entry => {
                    const receiptMatch = entry.receiptNumber ? entry.receiptNumber.toLowerCase().includes(searchTerm) : false;
                    const nameMatch = entry.name?.toLowerCase().includes(searchTerm);
                    const purposeMatch = entry.purpose?.toLowerCase().includes(searchTerm);
                    const amountMatch = String(entry.amount)?.toLowerCase().includes(searchTerm);
                    const dateMatch = entry.date?.toLowerCase().includes(searchTerm);
                    const categoryMatch = entry.category?.toLowerCase().includes(searchTerm);
                    return receiptMatch || nameMatch || purposeMatch || amountMatch || dateMatch || categoryMatch;
                });
            }

            if (displayedData.length === 0 && searchTerm === '') {
                tbody.innerHTML = '<tr><td colspan="9" class="text-center text-muted">No Paid Entries.</td></tr>';
            } else if (displayedData.length === 0 && searchTerm !== '') {
                tbody.innerHTML = '<tr><td colspan="9" class="text-center text-muted">No matching results found.</td></tr>';
            }


            displayedData.forEach((entry, index) => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${entry.receiptNumber || 'N/A'}</td>
                    <td>${entry.name}</td>
                    <td>${entry.purpose}</td>
                    <td>${entry.amount.toFixed(2)}</td>
                    <td>${entry.date}</td>
                    <td>${entry.status}</td>
                    <td>${entry.category}</td>
                    <td>
                        <button class="btn btn-danger btn-sm" onclick="deletePaidEntry('${entry.id}')">Delete</button>
                    </td>
                `;
                tbody.appendChild(tr);
            });
            document.getElementById('paidCount').textContent = displayedData.length;
        }

        // Populate Paid Category Filter
        function populatePaidCategoryFilter() {
            const paidFilterCategorySelect = document.getElementById('paidFilterCategory');
            let categories = new Set(paidEntries.map(entry => entry.category));

            let currentValue = paidFilterCategorySelect.value;

            paidFilterCategorySelect.innerHTML = '<option value="all">All</option>';
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                paidFilterCategorySelect.appendChild(option);
            });

            if (categories.has(currentValue)) {
                paidFilterCategorySelect.value = currentValue;
            } else {
                paidFilterCategorySelect.value = 'all';
            }
            currentPaidFilterCategory = paidFilterCategorySelect.value;
        }

        // Delete Paid Entry from Firebase
        function deletePaidEntry(entryId) {
            if (!isAuthReady || !firebaseUserId) {
                showError("Firebase is not ready. Please wait.");
                return;
            }
            showConfirmation('Are you sure you want to delete this paid entry? This action cannot be undone.', async () => {
                try {
                    await deleteDoc(doc(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/paidEntries`, entryId));
                    showSuccess('Paid entry successfully deleted!');
                }
                catch (error) {
                    console.error("Error deleting paid entry: ", error);
                    showError("Error deleting entry. Please try again.");
                }
            });
        }

        // Filter Paid Report by Category
        function filterPaidList() {
            currentPaidFilterCategory = document.getElementById('paidFilterCategory').value;
            document.getElementById('paidSearchInput').value = '';
            renderPaidReport();
        }

        // Search Paid Report
        function searchPaidReport() {
            document.getElementById('paidFilterCategory').value = 'all';
            currentPaidFilterCategory = 'all';
            renderPaidReport();
        }

        // Export Paid Report PDF
        function exportPaidPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            let dataToExport = currentPaidFilterCategory === 'all' ? [...paidEntries] : paidEntries.filter(e => String(e.category) === String(currentPaidFilterCategory));

            const searchTerm = document.getElementById('paidSearchInput')?.value?.toLowerCase().trim() || '';
            if (searchTerm !== '') {
                dataToExport = dataToExport.filter(entry => {
                    const receiptMatch = entry.receiptNumber ? entry.receiptNumber.toLowerCase().includes(searchTerm) : false;
                    const nameMatch = entry.name?.toLowerCase().includes(searchTerm);
                    const purposeMatch = entry.purpose?.toLowerCase().includes(searchTerm);
                    const amountMatch = String(entry.amount)?.toLowerCase().includes(searchTerm);
                    const dateMatch = entry.date?.toLowerCase().includes(searchTerm);
                    const categoryMatch = entry.category?.toLowerCase().includes(searchTerm);
                    return receiptMatch || nameMatch || purposeMatch || amountMatch || dateMatch || categoryMatch;
                });
            }

            doc.text('Paid Report', 14, 15);
            doc.autoTable({
                startY: 20,
                head: [['Serial', 'Receipt No.', 'Name', 'Purpose', 'Amount', 'Date', 'Status', 'Category']],
                body: dataToExport.map((e, i) => [i + 1, e.receiptNumber, e.name, e.purpose, e.amount, e.date, e.status, e.category])
            });
            doc.save('paid_report.pdf');
            showSuccess('Paid Report exported as PDF');
        }

        // Export Paid Report Excel
        function exportPaidExcel() {
            const wb = XLSX.utils.book_new();
            let dataToExport = currentPaidFilterCategory === 'all' ? [...paidEntries] : paidEntries.filter(e => String(e.category) === String(currentPaidFilterCategory));

            const searchTerm = document.getElementById('paidSearchInput')?.value?.toLowerCase().trim() || '';
            if (searchTerm !== '') {
                dataToExport = dataToExport.filter(entry => {
                    const receiptMatch = entry.receiptNumber ? entry.receiptNumber.toLowerCase().includes(searchTerm) : false;
                    const nameMatch = entry.name?.toLowerCase().includes(searchTerm);
                    const purposeMatch = entry.purpose?.toLowerCase().includes(searchTerm);
                    const amountMatch = String(entry.amount)?.toLowerCase().includes(searchTerm);
                    const dateMatch = entry.date?.toLowerCase().includes(searchTerm);
                    const categoryMatch = entry.category?.toLowerCase().includes(searchTerm);
                    return receiptMatch || nameMatch || purposeMatch || amountMatch || dateMatch || categoryMatch;
                });
            }

            const wsData = [
                ['Serial', 'Receipt No.', 'Name', 'Purpose', 'Amount', 'Date', 'Status', 'Category'],
                ...dataToExport.map((e, i) => [i + 1, e.receiptNumber, e.name, e.purpose, e.amount, e.date, e.status, e.category])
            ];
            const ws = XLSX.utils.aoa_to_sheet(wsData);
            XLSX.utils.book_append_sheet(wb, ws, 'Paid Report');
            XLSX.writeFile(wb, 'paid_report.xlsx');
            showSuccess('Paid Report exported as Excel');
        }

        // ------------ Admin Panel Functions ------------

        // Add Login User to Firebase (public collection)
        async function addLoginUser(e) {
            e.preventDefault();
            if (!isAuthReady || !firebaseUserId) {
                showError("Firebase is not ready. Please wait.");
                return;
            }
            if (!loggedInUser) { // Only allow admin to add users for consistency with original app
                showError("You must be logged in to add a login user.");
                return;
            }

            const username = document.getElementById('newUsernameInput').value.trim();
            const password = document.getElementById('newPasswordInput').value.trim();
            const securityQuestion = document.getElementById('newSecurityQuestionInput').value;
            const securityAnswer = document.getElementById('newSecurityAnswerInput').value.trim();

            if (loginUsers.some(user => user.username === username)) {
                showError('Username already exists!');
                return;
            }

            if (!username || !password || !securityQuestion || !securityAnswer) {
                showError('Please fill all fields to add a new user.');
                return;
            }

            try {
                // Now directly uses 'loginUsers' as a top-level collection
                await addDoc(collection(db, `loginUsers`), {
                    username,
                    password,
                    securityQuestion,
                    securityAnswer
                });
                showSuccess('Login user added successfully!');
                document.getElementById('addLoginForm').reset();
                loginUserModal.hide(); // Close if open to re-render
                showLoginUsers(); // Refresh list immediately if open
            }
            catch (error) {
                console.error("Error adding login user:", error);
                showError("Error adding login user. Please try again.");
            }
        }

        // Show Login Users in a modal (from Firebase)
        function showLoginUsers() {
            const list = document.getElementById('loginUserList');
            list.innerHTML = '';
            if (loginUsers.length === 0) {
                list.innerHTML = '<li class="list-group-item text-center text-muted">No Login Users.</li>';
            } else {
                loginUsers.forEach((user) => {
                    const li = document.createElement('li');
                    li.className = 'list-group-item d-flex justify-content-between align-items-center';
                    li.innerHTML = `
                        <span>Username: ${user.username} (Password: ${user.password})<br>
                        Security Q: ${user.securityQuestion || 'N/A'}<br>
                        Security A: ${user.securityAnswer || 'N/A'}</span>
                        <div>
                            <button class="btn btn-warning btn-sm me-2" onclick="editLoginUser('${user.id}')">Edit</button>
                            <button class="btn btn-danger btn-sm" onclick="confirmDeleteLoginUser('${user.id}')">Delete</button>
                        </div>
                    `;
                    list.appendChild(li);
                });
            }
            loginUserModal.show();
        }

        // Close Login User Modal
        function closeLoginUserModal() {
            loginUserModal.hide();
        }

        // Edit Login User (populate modal)
        function editLoginUser(docId) {
            const user = loginUsers.find(u => u.id === docId);
            if (user) {
                document.getElementById('editUserDocId').value = docId;
                document.getElementById('editUsernameInput').value = user.username;
                document.getElementById('editPasswordInput').value = ''; // Clear password field for security
                document.getElementById('editSecurityQuestionInput').value = user.securityQuestion || '';
                document.getElementById('editSecurityAnswerInput').value = user.securityAnswer || '';
                editLoginUserModal.show();
            } else {
                showError("User not found!");
            }
        }

        // Save Edited Login User to Firebase
        async function saveEditedLoginUser() {
            if (!isAuthReady || !firebaseUserId) {
                showError("Firebase is not ready. Please wait.");
                return;
            }
            if (!loggedInUser) {
                showError("You must be logged in to edit login users.");
                return;
            }

            const docId = document.getElementById('editUserDocId').value;
            // Now directly uses 'loginUsers' as a top-level collection
            const userRef = doc(db, `loginUsers`, docId);
            const newUsername = document.getElementById('editUsernameInput').value.trim();
            const newPassword = document.getElementById('editPasswordInput').value.trim();
            const newSecurityQuestion = document.getElementById('editSecurityQuestionInput').value;
            const newSecurityAnswer = document.getElementById('editSecurityAnswerInput').value.trim();

            // Check if new username already exists for another user (excluding current user)
            if (loginUsers.some((u) => u.id !== docId && u.username === newUsername)) {
                showError('Username already exists!');
                return;
            }

            const updateData = {
                username: newUsername,
                securityQuestion: newSecurityQuestion,
                securityAnswer: newSecurityAnswer
            };
            if (newPassword) {
                updateData.password = newPassword;
            }

            try {
                await updateDoc(userRef, updateData);
                editLoginUserModal.hide();
                showSuccess('Login user updated successfully!');
                showLoginUsers(); // Refresh the list
            }
            catch (error) {
                console.error("Error updating login user:", error);
                showError("Error updating login user. Please try again.");
            }
        }

        // Confirm Delete Login User
        function confirmDeleteLoginUser(docId) {
            const userToDelete = loginUsers.find(u => u.id === docId);
            if (!userToDelete) {
                showError("User not found!");
                return;
            }

            if (userToDelete.username === 'admin' && loginUsers.length > 1) {
                showError('Cannot delete the default "admin" user if other users exist. Please create another admin user first.');
                return;
            }
            if (loginUsers.length === 1 && userToDelete.username === 'admin') {
                showError('Cannot delete the only "admin" user. At least one admin user must exist.');
                return;
            }
            if (userToDelete.username === loggedInUser) {
                showError('You cannot delete your own active login session. Please log out first if you wish to delete this account.');
                return;
            }

            showConfirmation('Are you sure you want to delete this login user? This action cannot be undone.', async () => {
                try {
                    // Now directly uses 'loginUsers' as a top-level collection
                    await deleteDoc(doc(db, `loginUsers`, docId));
                    showSuccess('Login user successfully deleted!');
                    showLoginUsers(); // Refresh the list
                }
                catch (error) {
                    console.error("Error deleting login user:", error);
                    showError("Error deleting login user. Please try again.");
                }
            });
        }

        // Add Name for Dropdowns to Firebase
        async function addDropdownName(e) {
            e.preventDefault();
            if (!isAuthReady || !firebaseUserId) {
                showError("Firebase is not ready. Please wait.");
                return;
            }
            if (!loggedInUser) {
                showError("You must be logged in to add names.");
                return;
            }

            const name = document.getElementById('newDropdownNameInput').value.trim();
            if (name && !dropdownNames.includes(name)) {
                const dropdownNamesDocRef = doc(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/metadata/dropdownNames`);
                try {
                    await updateDoc(dropdownNamesDocRef, {
                        names: [...dropdownNames, name]
                    }, { merge: true }); // Use merge to add/update array
                    showSuccess('Name added to dropdowns!');
                    document.getElementById('addDropdownNameForm').reset();
                }
                catch (error) {
                    console.error("Error adding dropdown name:", error);
                    showError("Error adding dropdown name. Please try again.");
                }
            } else if (dropdownNames.includes(name)) {
                showError('Name already exists in dropdowns!');
            } else {
                showError('Please enter a name.');
            }
        }

        // Show Dropdown Names in a modal (from Firebase)
        function showDropdownNames() {
            const list = document.getElementById('dropdownNameList');
            list.innerHTML = '';
            if (dropdownNames.length === 0) {
                list.innerHTML = '<li class="list-group-item text-center text-muted">No Dropdown Names.</li>';
            } else {
                dropdownNames.forEach((name) => { // Removed index as it's not used for deletion by Firebase ID
                    const li = document.createElement('li');
                    li.className = 'list-group-item d-flex justify-content-between align-items-center';
                    li.innerHTML = `
                        <span>${name}</span>
                        <button class="btn btn-danger btn-sm" onclick="confirmDeleteDropdownName('${name}')">Delete</button>
                    `;
                    list.appendChild(li);
                });
            }
            dropdownNameModal.show();
        }

        // Close Dropdown Name Modal
        function closeDropdownNameModal() {
            dropdownNameModal.hide();
        }

        // Confirm Delete Dropdown Name
        function confirmDeleteDropdownName(nameToDelete) {
            showConfirmation('Are you sure you want to delete this name from dropdowns? This will not affect existing entries but the name will no longer appear as an option.', async () => {
                try {
                    const dropdownNamesDocRef = doc(db, `artifacts/${appIdEnv}/users/${firebaseUserId}/metadata/dropdownNames`);
                    const newNames = dropdownNames.filter(name => name !== nameToDelete);
                    await updateDoc(dropdownNamesDocRef, { names: newNames });
                    showSuccess('Name successfully deleted from dropdowns!');
                    showDropdownNames(); // Refresh the list
                }
                catch (error) {
                    console.error("Error deleting dropdown name:", error);
                    showError("Error deleting dropdown name. Please try again.");
                }
            });
        }

        // Note about Backup/Restore: Removed as Firebase manages persistence.
        // function backupDatabase() { /* ... removed ... */ }
        // function restoreDatabase(event) { /* ... removed ... */ }

        // Forgot Password Functions (interacts with public loginUsers)
        function showForgotPasswordModal() {
            document.getElementById('resetPasswordForm').reset();
            forgotPasswordModal.show();
        }

        async function resetPassword(e) {
            e.preventDefault();
            if (!isAuthReady || !firebaseUserId) {
                showError("Firebase is not ready. Please wait.");
                return;
            }

            const username = document.getElementById('resetUsernameInput').value.trim();
            const securityQuestion = document.getElementById('resetSecurityQuestionInput').value;
            const securityAnswer = document.getElementById('resetSecurityAnswerInput').value.trim();
            const newPassword = document.getElementById('newPasswordResetInput').value.trim();
            const confirmPassword = document.getElementById('confirmPasswordResetInput').value.trim();

            const user = loginUsers.find(u => u.username === username);

            if (!user) {
                showError('User not found.');
                return;
            }

            if (user.securityQuestion !== securityQuestion || user.securityAnswer.toLowerCase() !== securityAnswer.toLowerCase()) {
                showError('Incorrect security question or answer.');
                return;
            }

            if (newPassword !== confirmPassword) {
                showError('New password and confirm password do not match.');
                return;
            }

            if (newPassword.length < 1) {
                showError('New password cannot be empty.');
                return;
            }

            try {
                // Now directly uses 'loginUsers' as a top-level collection
                const userRef = doc(db, `loginUsers`, user.id);
                await updateDoc(userRef, { password: newPassword });
                forgotPasswordModal.hide();
                showSuccess('Password reset successfully! You can now log in with your new password.');
                document.getElementById('loginForm').reset();
                document.getElementById('loginError').style.display = 'none';
            }
            catch (error) {
                console.error("Error resetting password:", error);
                showError("Error resetting password. Please try again.");
            }
        }

        // Initialize filtering and rendering on initial load (after Firebase auth and data listeners are set up)
        // These will be automatically called by onSnapshot listeners, so no need for explicit calls here.
        // renderDueList();
        // renderIncomingList();
        // renderPaidReport();
        // populateNameDropdowns();
        // populatePaidCategoryFilter();
        // checkLoginStatus(); // This is called by onAuthStateChanged
    </script>
</body>
</html>
