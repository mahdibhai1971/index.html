<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Mahdi Due Tracker</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
<script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
<style>
  body { padding: 20px; background: #f9f9f9; font-family: Arial, sans-serif; }
  header { display: flex; align-items: center; margin-bottom: 15px; }
  .logo-circle {
    width: 45px; height: 45px; background-color: #0d6efd;
    color: white; border-radius: 50%; font-weight: 700;
    display: flex; justify-content: center; align-items: center;
    font-size: 1.4rem; user-select:none;
  }
  header h1 {
    margin-left: 12px; font-size: 1.8rem; font-weight: 700; color: #0d6efd;
  }
  .nav-buttons {
    margin-bottom: 20px;
  }
  .nav-buttons button {
    margin-right: 8px;
    font-size: 14px;
    min-width: 110px;
  }
  .page {
    display: none;
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
  }
  .page.active {
    display: block;
    opacity: 1;
  }
  table th, table td {
    vertical-align: middle !important;
  }
  .form-select, .form-control {
    font-size: 14px;
  }
  .required-star {
    color: red;
    margin-left: 3px;
  }
  /* Popup success modal */
  .modal-success .modal-header {
    background-color: #198754;
    color: white;
  }
  .modal-error .modal-header {
    background-color: #dc3545;
    color: white;
  }
  .login-container {
    max-width: 400px;
    margin: 50px auto;
    padding: 30px;
    border: 1px solid #ddd;
    border-radius: 8px;
    background-color: #fff;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
  }
  .logged-in-user {
    margin-left: auto;
    display: flex;
    align-items: center;
  }
  .logged-in-user span {
    margin-right: 10px;
    font-weight: bold;
    color: #0d6efd;
  }
  /* Due Collect specific styles */
  .due-collect-selection button {
    margin-right: 10px;
    margin-bottom: 10px;
  }
  .due-collect-table-container {
      margin-top: 20px;
      border: 1px solid #e9ecef;
      border-radius: 5px;
      overflow: hidden;
  }
  .filter-group {
    display: flex;
    align-items: flex-end;
    gap: 10px;
    margin-bottom: 10px; /* Add some space below the filter group */
  }
  .filter-group > div {
    flex-grow: 1;
  }
  .filter-group .form-label {
    margin-bottom: 5px; /* Adjust label spacing */
  }
</style>
</head>
<body>

<!-- Header -->
<header>
  <div class="logo-circle">MH</div>
  <h1>Mahdi Due Tracker</h1>
  <div class="logged-in-user" id="loggedInUserDisplay" style="display: none;">
    <span id="currentUsername"></span>
    <button class="btn btn-outline-danger btn-sm" onclick="logout()">Logout</button>
  </div>
</header>

<!-- Nav Buttons -->
<div class="nav-buttons" id="mainNavButtons" style="display: none;">
  <button class="btn btn-primary" onclick="showPage('dueListPage')">Due List</button>
  <button class="btn btn-success" onclick="showPage('incomingFundsPage')">Incoming Funds</button>
  <button class="btn btn-secondary" onclick="showPage('dueCollectPage')">Due Collect</button>
  <button class="btn btn-warning" onclick="showPage('paidReportPage')">Paid Report</button>
  <button class="btn btn-secondary" onclick="showPage('adminPage')">Admin Panel</button>
  <button class="btn btn-info" onclick="showPage('infoPage')">Info</button>
</div>

<!-- Page: Login -->
<div id="loginPage" class="page active">
  <div class="login-container">
    <h4 class="mb-3 text-center">Login to Mahdi Due Tracker</h4>
    <form id="loginForm" onsubmit="login(event)">
      <div class="mb-3">
        <label for="usernameInput" class="form-label">Username:</label>
        <input type="text" id="usernameInput" class="form-control" required />
      </div>
      <div class="mb-3">
        <label for="passwordInput" class="form-label">Password:</label>
        <input type="password" id="passwordInput" class="form-control" required />
      </div>
      <button type="submit" class="btn btn-primary w-100">Login</button>
    </form>
    <div class="alert alert-danger mt-3" id="loginError" style="display:none;"></div>
    <div class="mt-3 text-center">
      <a href="#" onclick="showForgotPasswordModal()">Forgot Password?</a>
    </div>
  </div>
</div>

<!-- Page: Due List -->
<div id="dueListPage" class="page">
  <h4>Due List Entry Form</h4>
  <form id="dueEntryForm" onsubmit="addDueEntry(event)" class="mb-3">
    <div class="row g-2 align-items-end">
      <div class="col-md-3">
        <label for="dueName" class="form-label">Name <span class="required-star">*</span></label>
        <select id="dueName" class="form-select" required></select>
      </div>
      <div class="col-md-3">
        <label for="duePurpose" class="form-label">Purpose <span class="required-star">*</span></label>
        <input type="text" id="duePurpose" class="form-control" required />
      </div>
      <div class="col-md-2">
        <label for="dueAmount" class="form-label">Amount <span class="required-star">*</span></label>
        <input type="number" id="dueAmount" class="form-control" min="0" step="any" required />
      </div>
      <div class="col-md-2">
        <label for="dueDate" class="form-label">Date <span class="required-star">*</span></label>
        <input type="date" id="dueDate" class="form-control" required />
      </div>
      <div class="col-md-2">
        <label for="dueStatus" class="form-label">Status <span class="required-star">*</span></label>
        <select id="dueStatus" class="form-select" required>
          <option value="Due" selected>Due</option>
          <!-- Removed Paid here as per your request -->
        </select>
      </div>
    </div>
    <button type="submit" class="btn btn-primary mt-3">Add Due Entry</button>
  </form>

  <div class="row mb-2">
    <div class="col-md-6 filter-group">
      <div>
        <label for="dueFilterName" class="form-label">Filter by Name:</label>
        <select id="dueFilterName" class="form-select" onchange="filterDueList()">
          <option value="all" selected>All</option>
        </select>
      </div>
      <div>
        <label for="dueSearchInput" class="form-label">Search:</label>
        <input type="text" id="dueSearchInput" class="form-control" placeholder="Search name, purpose, amount, date..." onkeyup="searchDueList()" />
      </div>
    </div>
    <div class="col-md-6 d-flex align-items-end justify-content-end">
      <button class="btn btn-primary me-2" onclick="exportDuePDF()">Export PDF</button>
      <button class="btn btn-success" onclick="exportDueExcel()">Export Excel</button>
    </div>
  </div>

  <table id="dueTable" class="table table-bordered table-striped align-middle">
    <thead class="table-primary">
      <tr>
        <th>Serial</th>
        <th>Name</th>
        <th>Purpose</th>
        <th>Amount</th>
        <th>Date</th>
        <th>Status</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody></tbody>
    <tfoot>
      <tr>
        <th colspan="2">Total Due Amount</th>
        <th id="dueTotalAmount" colspan="5"></th>
      </tr>
    </tfoot>
  </table>
</div>

<!-- Page: Incoming Funds -->
<div id="incomingFundsPage" class="page">
  <h4>Incoming Funds Entry Form</h4>
  <form id="incomingEntryForm" onsubmit="addIncomingEntry(event)" class="mb-3">
    <div class="row g-2 align-items-end">
      <div class="col-md-3">
        <label for="incomingName" class="form-label">Name <span class="required-star">*</span></label>
        <select id="incomingName" class="form-select" required></select>
      </div>
      <div class="col-md-3">
        <label for="incomingPurpose" class="form-label">Purpose <span class="required-star">*</span></label>
        <input type="text" id="incomingPurpose" class="form-control" required />
      </div>
      <div class="col-md-2">
        <label for="incomingAmount" class="form-label">Amount <span class="required-star">*</span></label>
        <input type="number" id="incomingAmount" class="form-control" min="0" step="any" required />
      </div>
      <div class="col-md-2">
        <label for="incomingDate" class="form-label">Date <span class="required-star">*</span></label>
        <input type="date" id="incomingDate" class="form-control" required />
      </div>
      <div class="col-md-2">
        <label for="incomingStatus" class="form-label">Status <span class="required-star">*</span></label>
        <select id="incomingStatus" class="form-select" required>
          <option value="Due" selected>Due</option>
          <!-- Paid option removed here -->
        </select>
      </div>
    </div>
    <button type="submit" class="btn btn-success mt-3">Add Incoming Entry</button>
  </form>

  <div class="row mb-2">
    <div class="col-md-6 filter-group">
      <div>
        <label for="incomingFilterName" class="form-label">Filter by Name:</label>
        <select id="incomingFilterName" class="form-select" onchange="filterIncomingList()">
          <option value="all" selected>All</option>
        </select>
      </div>
      <div>
        <label for="incomingSearchInput" class="form-label">Search:</label>
        <input type="text" id="incomingSearchInput" class="form-control" placeholder="Search name, purpose, amount, date..." onkeyup="searchIncomingList()" />
      </div>
    </div>
    <div class="col-md-6 d-flex align-items-end justify-content-end">
      <button class="btn btn-primary me-2" onclick="exportIncomingPDF()">Export PDF</button>
      <button class="btn btn-success" onclick="exportIncomingExcel()">Export Excel</button>
    </div>
  </div>

  <table id="incomingTable" class="table table-bordered table-striped align-middle">
    <thead class="table-success">
      <tr>
        <th>Serial</th>
        <th>Name</th>
        <th>Purpose</th>
        <th>Amount</th>
        <th>Date</th>
        <th>Status</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody></tbody>
    <tfoot>
      <tr>
        <th colspan="2">Total Due Amount</th>
        <th id="incomingTotalAmount" colspan="5"></th>
      </tr>
    </tfoot>
  </table>
</div>

<!-- Page: Due Collect -->
<div id="dueCollectPage" class="page">
  <h4>Due Collection</h4>
  <div class="mb-3 due-collect-selection">
    <button class="btn btn-primary" onclick="displayCollectionTable('due')">Collect from Due List</button>
    <button class="btn btn-success" onclick="displayCollectionTable('incoming')">Collect from Incoming Funds</button>
  </div>

  <div id="dueCollectTableContainer" class="due-collect-table-container">
    <!-- Dynamic table will be loaded here -->
    <p class="text-center text-muted p-3">Select a source (Due List or Incoming Funds) to start collecting.</p>
  </div>
</div>

<!-- Page: Paid Report -->
<div id="paidReportPage" class="page">
  <h4>Paid Report</h4>
  <div class="row mb-2">
    <div class="col-md-6 filter-group">
      <div>
        <label for="paidFilterCategory" class="form-label">Filter by Category:</label>
        <select id="paidFilterCategory" class="form-select" onchange="filterPaidList()">
          <option value="all" selected>All</option>
        </select>
      </div>
      <div>
        <label for="paidSearchInput" class="form-label">Search:</label>
        <input type="text" id="paidSearchInput" class="form-control" placeholder="Search name, purpose, amount, date, receipt..." onkeyup="searchPaidReport()" />
      </div>
    </div>
    <div class="col-md-6 d-flex align-items-end justify-content-end">
      <button class="btn btn-primary me-2" onclick="exportPaidPDF()">Export PDF</button>
      <button class="btn btn-success" onclick="exportPaidExcel()">Export Excel</button>
      <h6 class="ms-3">Total Entries: <span id="paidCount">0</span></h6>
    </div>
  </div>

  <table id="paidTable" class="table table-bordered table-striped align-middle">
    <thead class="table-warning">
      <tr>
        <th>Serial</th>
        <th>Receipt No.</th> <!-- New Column -->
        <th>Name</th>
        <th>Purpose</th>
        <th>Amount</th>
        <th>Date</th>
        <th>Status</th>
        <th>Category</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<!-- Page: Admin Panel -->
<div id="adminPage" class="page">
  <h4>Admin Panel</h4>

  <div class="card mb-4">
    <div class="card-header bg-primary text-white">
      <h5>Add New Login User</h5>
    </div>
    <div class="card-body">
      <form id="addLoginForm" onsubmit="addLoginUser(event)">
        <div class="mb-3">
          <label for="newUsernameInput" class="form-label">Username:</label>
          <input type="text" id="newUsernameInput" class="form-control" required />
        </div>
        <div class="mb-3">
          <label for="newPasswordInput" class="form-label">Password:</label>
          <input type="password" id="newPasswordInput" class="form-control" required />
        </div>
        <div class="mb-3">
          <label for="newSecurityQuestionInput" class="form-label">Security Question:</label>
          <select id="newSecurityQuestionInput" class="form-select" required>
            <option value="" disabled selected>Select a security question</option>
            <option value="We need your number to proceed — could you confirm it?">We need your number to proceed — could you confirm it?</option>
            <option value="We need your district to proceed - Could you confirm it?">We need your district to proceed - Could you confirm it?</option>
            <option value="We need your secret number to verify you - could you confirm it?">We need your secret number to verify you - could you confirm it?</option>
          </select>
        </div>
        <div class="mb-3">
          <label for="newSecurityAnswerInput" class="form-label">Security Answer:</label>
          <input type="text" id="newSecurityAnswerInput" class="form-control" required />
        </div>
        <button type="submit" class="btn btn-primary">Add Login User</button>
      </form>
    </div>
  </div>

  <div class="card mb-4">
    <div class="card-header bg-success text-white">
      <h5>Add Name for Dropdowns</h5>
    </div>
    <div class="card-body">
      <form id="addDropdownNameForm" onsubmit="addDropdownName(event)">
        <div class="mb-3">
          <label for="newDropdownNameInput" class="form-label">Name:</label>
          <input type="text" id="newDropdownNameInput" class="form-control" placeholder="Enter new name for dropdowns" required />
        </div>
        <button type="submit" class="btn btn-success">Add Name</button>
      </form>
    </div>
  </div>

  <div class="mb-3">
    <button class="btn btn-secondary me-2" onclick="showLoginUsers()">Show Login Users</button>
    <button class="btn btn-info me-2" onclick="showDropdownNames()">Show Dropdown Names</button>
    <button class="btn btn-success ms-2" onclick="backupDatabase()">Backup Database</button>
    <label class="btn btn-info ms-2 mb-0" for="restoreFileInput" style="cursor:pointer;">Restore Database</label>
    <input type="file" id="restoreFileInput" style="display:none;" accept="application/json" onchange="restoreDatabase(event)" />
  </div>

  <!-- Modals for displaying lists -->
  <div id="loginUserModal" class="modal" tabindex="-1">
    <div class="modal-dialog modal-dialog-scrollable">
      <div class="modal-content">
        <div class="modal-header bg-primary text-white">
          <h5 class="modal-title">Login Users List</h5>
          <button type="button" class="btn-close btn-close-white" onclick="closeLoginUserModal()"></button>
        </div>
        <div class="modal-body">
          <ul id="loginUserList" class="list-group"></ul>
        </div>
      </div>
    </div>
  </div>

  <div id="dropdownNameModal" class="modal" tabindex="-1">
    <div class="modal-dialog modal-dialog-scrollable">
      <div class="modal-content">
        <div class="modal-header bg-success text-white">
          <h5 class="modal-title">Dropdown Names List</h5>
          <button type="button" class="btn-close btn-close-white" onclick="closeDropdownNameModal()"></button>
        </div>
        <div class="modal-body">
          <ul id="dropdownNameList" class="list-group"></ul>
        </div>
      </div>
    </div>
  </div>

</div>

<!-- Page: Info -->
<div id="infoPage" class="page">
  <h4>Info</h4>
  <p>This is Mahdi Due Tracker, a simple and efficient tool to track due amounts, incoming funds, and paid reports. Developed by Mahdi Bhai.</p>
</div>

<!-- Modal Template for Success -->
<div class="modal fade" id="successModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content modal-success">
      <div class="modal-header">
        <h5 class="modal-title">Success</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="successModalBody"></div>
    </div>
  </div>
</div>

<!-- Modal Template for Error -->
<div class="modal fade" id="errorModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content modal-error">
      <div class="modal-header">
        <h5 class="modal-title">Error</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="errorModalBody"></div>
    </div>
  </div>
</div>

<!-- Custom Confirmation Modal HTML -->
<div class="modal fade" id="confirmationModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header bg-warning text-dark">
        <h5 class="modal-title">Confirmation</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="confirmationModalBody"></div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="confirmActionButton">Confirm</button>
      </div>
    </div>
  </div>
</div>

<!-- New Modal for Editing Login Users -->
<div class="modal fade" id="editLoginUserModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header bg-warning text-dark">
        <h5 class="modal-title">Edit Login User</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="editLoginForm">
          <input type="hidden" id="editUserIndex" />
          <div class="mb-3">
            <label for="editUsernameInput" class="form-label">Username:</label>
            <input type="text" id="editUsernameInput" class="form-control" required />
          </div>
          <div class="mb-3">
            <label for="editPasswordInput" class="form-label">Password:</label>
            <input type="password" id="editPasswordInput" class="form-control" placeholder="Leave empty to keep current password" />
          </div>
          <div class="mb-3">
            <label for="editSecurityQuestionInput" class="form-label">Security Question:</label>
            <select id="editSecurityQuestionInput" class="form-select">
              <option value="" disabled selected>Select a security question</option>
              <option value="We need your number to proceed — could you confirm it?">We need your number to proceed — could you confirm it?</option>
              <option value="We need your district to proceed - Could you confirm it?">We need your district to proceed - Could you confirm it?</option>
              <option value="We need your secret number to verify you - could you confirm it?">We need your secret number to verify you - could you confirm it?</option>
            </select>
          </div>
          <div class="mb-3">
            <label for="editSecurityAnswerInput" class="form-label">Security Answer:</label>
            <input type="text" id="editSecurityAnswerInput" class="form-control" placeholder="Enter security answer" />
          </div>
          <button type="button" class="btn btn-primary w-100" onclick="saveEditedLoginUser()">Save Changes</button>
        </form>
      </div>
    </div>
  </div>
</div>

<!-- New Modal for Forgot Password -->
<div class="modal fade" id="forgotPasswordModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header bg-info text-white">
        <h5 class="modal-title">Reset Password</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="resetPasswordForm" onsubmit="resetPassword(event)">
          <div class="mb-3">
            <label for="resetUsernameInput" class="form-label">Username:</label>
            <input type="text" id="resetUsernameInput" class="form-control" required />
          </div>
          <div class="mb-3">
            <label for="resetSecurityQuestionInput" class="form-label">Security Question:</label>
            <select id="resetSecurityQuestionInput" class="form-select" required>
              <option value="" disabled selected>Select your security question</option>
              <option value="We need your number to proceed — could you confirm it?">We need your number to proceed — could you confirm it?</option>
              <option value="We need your district to proceed - Could you confirm it?">We need your district to proceed - Could you confirm it?</option>
              <option value="We need your secret number to verify you - could you confirm it?">We need your secret number to verify you - could you confirm it?</option>
            </select>
          </div>
          <div class="mb-3">
            <label for="resetSecurityAnswerInput" class="form-label">Security Answer:</label>
            <input type="text" id="resetSecurityAnswerInput" class="form-control" required />
          </div>
          <div class="mb-3">
            <label for="newPasswordResetInput" class="form-label">New Password:</label>
            <input type="password" id="newPasswordResetInput" class="form-control" required />
          </div>
          <div class="mb-3">
            <label for="confirmPasswordResetInput" class="form-label">Confirm New Password:</label>
            <input type="password" id="confirmPasswordResetInput" class="form-control" required />
          </div>
          <button type="submit" class="btn btn-primary w-100">Reset Password</button>
        </form>
      </div>
    </div>
  </div>
</div>


<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script>
  // Data storage variables
  let dueEntries = [];
  let incomingEntries = [];
  let paidEntries = [];
  // Stores login users with username and password, and now security question/answer
  let loginUsers = [{ username: 'admin', password: 'password', securityQuestion: 'We need your number to proceed — could you confirm it?', securityAnswer: 'admin' }];
  // Stores names for dropdowns in Due List and Incoming Funds forms
  let dropdownNames = [];
  let loggedInUser = null; // Stores currently logged in user
  let receiptCounter = 0; // For unique receipt numbers

  // Global filter states for Due List and Incoming Funds pages
  let currentDueFilter = 'all';
  let currentIncomingFilter = 'all';
  let currentPaidFilterCategory = 'all'; // New filter state for Paid Report

  // For modals
  const loginUserModal = new bootstrap.Modal(document.getElementById('loginUserModal'));
  const dropdownNameModal = new bootstrap.Modal(document.getElementById('dropdownNameModal'));
  const successModal = new bootstrap.Modal(document.getElementById('successModal'));
  const successModalBody = document.getElementById('successModalBody');
  const errorModal = new bootstrap.Modal(document.getElementById('errorModal'));
  const errorModalBody = document.getElementById('errorModalBody');
  const confirmationModal = new bootstrap.Modal(document.getElementById('confirmationModal'));
  const confirmationModalBody = document.getElementById('confirmationModalBody');
  const confirmActionButton = document.getElementById('confirmActionButton');
  const editLoginUserModal = new bootstrap.Modal(document.getElementById('editLoginUserModal')); // New modal instance
  const forgotPasswordModal = new bootstrap.Modal(document.getElementById('forgotPasswordModal')); // New modal for Forgot Password
  
  let confirmCallback = null; // Callback for confirmation modal


  // Initialize page
  document.addEventListener('DOMContentLoaded', () => {
    loadData();
    populateNameDropdowns(); // Initial population only

    // Explicitly set initial filter selection and render
    document.getElementById('dueFilterName').value = currentDueFilter;
    document.getElementById('incomingFilterName').value = currentIncomingFilter;
    document.getElementById('paidFilterCategory').value = currentPaidFilterCategory;

    renderDueList(); // Render with initial 'all' filter
    renderIncomingList(); // Render with initial 'all' filter
    renderPaidReport();
    populatePaidCategoryFilter();
    checkLoginStatus(); // Check if user was already logged in from previous session
  });

  // Show page function
  function showPage(pageId) {
    if (!loggedInUser && pageId !== 'loginPage' && pageId !== 'infoPage') {
      showError('Please login to access this page.');
      showPage('loginPage');
      return;
    }
    // Specific logic for Due Collect page to show initial message
    if (pageId === 'dueCollectPage') {
        document.getElementById('dueCollectTableContainer').innerHTML = '<p class="text-center text-muted p-3">Select a source (Due List or Incoming Funds) to start collecting.</p>';
    }

    document.querySelectorAll('.page').forEach(page => {
      page.classList.remove('active');
    });
    document.getElementById(pageId).classList.add('active');
  }

  // Login/Logout Functions
  function checkLoginStatus() {
    const storedUser = localStorage.getItem('loggedInUser');
    console.log("checkLoginStatus called. Stored 'loggedInUser':", storedUser);
    console.log("Current loginUsers array state (from loadData):", loginUsers); // Added this to see the state after loadData

    if (storedUser) {
      loggedInUser = storedUser;
      // Check if the storedUser actually exists in the loginUsers array
      const userExists = loginUsers.some(user => String(user.username) === String(loggedInUser));
      console.log(`Stored user "${loggedInUser}" exists in loginUsers array:`, userExists);

      if (userExists) {
        document.getElementById('currentUsername').textContent = loggedInUser;
        document.getElementById('loggedInUserDisplay').style.display = 'flex';
        document.getElementById('mainNavButtons').style.display = 'block';
        showPage('dueListPage'); // Redirect to a default page after login
      } else {
        // Stored user does not exist in the current loginUsers array (e.g., deleted or corrupted data)
        console.warn(`Stored user "${storedUser}" not found in current loginUsers array. Forcing logout.`);
        loggedInUser = null;
        localStorage.removeItem('loggedInUser'); // Clear the invalid stored user
        showError('Previous session data is invalid. Please log in again.');
        showPage('loginPage');
        document.getElementById('loggedInUserDisplay').style.display = 'none';
        document.getElementById('mainNavButtons').style.display = 'none';
      }
    } else {
      loggedInUser = null; // Ensure loggedInUser is null if no stored user
      console.log("No 'loggedInUser' found in localStorage. Displaying login page.");
      showPage('loginPage');
      document.getElementById('loggedInUserDisplay').style.display = 'none';
      document.getElementById('mainNavButtons').style.display = 'none';
    }
  }

  function login(e) {
    e.preventDefault();
    const username = document.getElementById('usernameInput').value.trim();
    const password = document.getElementById('passwordInput').value.trim();
    const loginErrorDiv = document.getElementById('loginError');

    const userFound = loginUsers.find(user => user.username === username && user.password === password);

    if (userFound) {
      loggedInUser = username;
      localStorage.setItem('loggedInUser', username);
      document.getElementById('currentUsername').textContent = loggedInUser;
      document.getElementById('loggedInUserDisplay').style.display = 'flex';
      document.getElementById('mainNavButtons').style.display = 'block';
      loginErrorDiv.style.display = 'none';
      showSuccess('Logged in successfully!');
      showPage('dueListPage'); // Default page after login
    } else {
      loggedInUser = null;
      localStorage.removeItem('loggedInUser');
      loginErrorDiv.textContent = 'Invalid username or password. Please try again.';
      loginErrorDiv.style.display = 'block';
    }
  }

  function logout() {
    showConfirmation('Are you sure you want to log out?', () => {
      loggedInUser = null;
      localStorage.removeItem('loggedInUser');
      showSuccess('Logged out successfully!');
      checkLoginStatus(); // Redirects to login page
    });
  }


  // Load data from localStorage
  function loadData() {
    const storedDue = localStorage.getItem('dueEntries');
    const storedIncoming = localStorage.getItem('incomingEntries');
    const storedPaid = localStorage.getItem('paidEntries');
    const storedLoginUsers = localStorage.getItem('loginUsers');
    const storedDropdownNames = localStorage.getItem('dropdownNames');
    const storedReceiptCounter = localStorage.getItem('receiptCounter');

    dueEntries = storedDue ? JSON.parse(storedDue) : [];
    incomingEntries = storedIncoming ? JSON.parse(storedIncoming) : [];
    paidEntries = storedPaid ? JSON.parse(storedPaid) : [];

    // Log the raw storedLoginUsers to see if it's null, empty, or malformed
    console.log("Raw storedLoginUsers from localStorage:", storedLoginUsers);

    // Initialize loginUsers with default admin if not present, and ensure security fields exist
    let parsedLoginUsers = storedLoginUsers ? JSON.parse(storedLoginUsers) : [];
    if (parsedLoginUsers.length === 0) {
      parsedLoginUsers.push({ username: 'admin', password: 'password', securityQuestion: 'We need your number to proceed — could you confirm it?', securityAnswer: 'admin' });
    } else {
      // Ensure existing users have securityQuestion and securityAnswer fields
      parsedLoginUsers = parsedLoginUsers.map(user => {
        if (user.securityQuestion === undefined) user.securityQuestion = '';
        if (user.securityAnswer === undefined) user.securityAnswer = '';
        return user;
      });
    }
    loginUsers = parsedLoginUsers;
    // Log the parsed/initialized loginUsers array
    console.log("Initialized loginUsers array:", loginUsers);

    dropdownNames = storedDropdownNames ? JSON.parse(storedDropdownNames) : [];
    receiptCounter = storedReceiptCounter ? parseInt(storedReceiptCounter) : 0;
    
    // Backfill IDs and isEditing flag for existing data if they don't have one
    dueEntries.forEach(entry => { 
        if (!entry.id) entry.id = Date.now() + Math.random(); 
        if (entry.isEditing === undefined) entry.isEditing = false;
    });
    incomingEntries.forEach(entry => { 
        if (!entry.id) entry.id = Date.now() + Math.random(); 
        if (entry.isEditing === undefined) entry.isEditing = false;
    });
    paidEntries.forEach(entry => { 
        if (!entry.id) entry.id = Date.now() + Math.random(); 
        if (entry.isEditing === undefined) entry.isEditing = false;
    });

    console.log("Data loaded: dueEntries count:", dueEntries.length, "incomingEntries count:", incomingEntries.length, "paidEntries count:", paidEntries.length, "dropdownNames count:", dropdownNames.length, "receiptCounter:", receiptCounter);
  }

  // Save data to localStorage
  function saveData() {
    localStorage.setItem('dueEntries', JSON.stringify(dueEntries));
    localStorage.setItem('incomingEntries', JSON.stringify(incomingEntries));
    localStorage.setItem('paidEntries', JSON.stringify(paidEntries));
    localStorage.setItem('loginUsers', JSON.stringify(loginUsers));
    localStorage.setItem('dropdownNames', JSON.stringify(dropdownNames));
    localStorage.setItem('receiptCounter', receiptCounter.toString());
  }

  // Generate unique receipt number
  function generateReceiptNumber() {
      const date = new Date();
      const year = date.getFullYear().toString().slice(-2);
      const month = (date.getMonth() + 1).toString().padStart(2, '0');
      const day = date.getDate().toString().padStart(2, '0');
      const hour = date.getHours().toString().padStart(2, '0');
      const minute = date.getMinutes().toString().padStart(2, '0');
      const second = date.getSeconds().toString().padStart(2, '0');
      receiptCounter++;
      saveData(); // Save updated counter immediately
      return `RC-${year}${month}${day}-${hour}${minute}${second}-${receiptCounter}`;
  }

  // Helper to clean purpose string from (Collected: X) tags
  function cleanPurpose(purpose) {
    let cleaned = purpose;
    const regex = /\s*\(Collected:\s*[^)]+\)/g; // Regex to match (Collected: ...)
    cleaned = cleaned.replace(regex, '').trim();
    return cleaned;
  }

  // Populate name dropdowns in entry forms & filters (uses dropdownNames)
  function populateNameDropdowns() {
    const dueNameSelect = document.getElementById('dueName');
    const incomingNameSelect = document.getElementById('incomingName');
    const dueFilter = document.getElementById('dueFilterName');
    const incomingFilter = document.getElementById('incomingFilterName');

    [dueNameSelect, incomingNameSelect, dueFilter, incomingFilter].forEach(select => {
      // Store current value before clearing, if it's a filter dropdown
      let currentValue = ''; // Default for normal selects
      if (select === dueFilter) currentValue = currentDueFilter;
      if (select === incomingFilter) currentValue = currentIncomingFilter;

      select.innerHTML = ''; // Clear existing options

      // Add default "Select Name" or "All" option
      if (select === dueFilter || select === incomingFilter) {
        select.innerHTML += '<option value="all">All</option>';
      } else {
        select.innerHTML += '<option value="" disabled selected>Select Name</option>';
      }
      
      // Add names from dropdownNames
      dropdownNames.forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        select.appendChild(option);
      });

      // Re-select the appropriate value based on stored filter state
      if (select === dueFilter) {
          select.value = currentDueFilter;
      } else if (select === incomingFilter) {
          select.value = currentIncomingFilter;
      } else if (dropdownNames.includes(currentValue)) { // For entry form selects, only re-select if the value is valid
          select.value = currentValue;
      } else {
        select.value = ""; // Default for entry forms if no valid selection
      }
    });
  }

  // ------------ Due List Functions ------------

  // Render Due List table
  function renderDueList(dataToRender = null) { // Added dataToRender argument
    console.log("renderDueList called. Data to render:", dataToRender ? "Filtered Data" : "All Due Entries");
    populateNameDropdowns(); // Re-populate to update filter dropdown's options if dropdownNames changed
    const tbody = document.querySelector('#dueTable tbody');
    tbody.innerHTML = '';

    let displayedData = dataToRender;

    if (displayedData === null) { // If no override, apply current filter
        displayedData = currentDueFilter === 'all' ? dueEntries : dueEntries.filter(e => String(e.name) === String(currentDueFilter));
    }
    
    displayedData.forEach((entry, index) => {
      console.log(`Rendering Due Entry: ID: ${entry.id}, Typeof ID: ${typeof entry.id}, Name: ${entry.name}, isEditing: ${entry.isEditing}, Status: ${entry.status}`);
      const tr = document.createElement('tr');
      // Editable fields logic
      const nameCell = entry.isEditing ? `<select class="form-select" id="editDueName-${entry.id}">${getDropdownNamesOptions(entry.name)}</select>` : `<span>${entry.name}</span>`;
      const purposeCell = entry.isEditing ? `<input type="text" class="form-control" value="${entry.purpose}" id="editDuePurpose-${entry.id}" />` : `<span>${entry.purpose}</span>`;
      const amountCell = entry.isEditing ? `<input type="number" class="form-control" value="${entry.amount}" min="0" step="any" id="editDueAmount-${entry.id}" />` : `<span>${entry.amount}</span>`;
      const dateCell = entry.isEditing ? `<input type="date" class="form-control" value="${entry.date}" id="editDueDate-${entry.id}" />` : `<span>${entry.date}</span>`;
      const statusCell = `
        <select class="form-select" id="editDueStatus-${entry.id}" onchange="updateDueEntryStatusFromSelect('${entry.id}', this.value)" ${entry.isEditing ? '' : 'disabled'}>
          <option value="Due" ${entry.status === 'Due' ? 'selected' : ''}>Due</option>
          <option value="Paid" ${entry.status === 'Paid' ? 'selected' : ''}>Paid</option>
        </select>
      `;

      tr.innerHTML = `
        <td>${index + 1}</td> <!-- Serial Number -->
        <td>${nameCell}</td>
        <td>${purposeCell}</td>
        <td>${amountCell}</td>
        <td>${dateCell}</td>
        <td>${statusCell}</td>
        <td>
          ${entry.isEditing ? `
            <button class="btn btn-success btn-sm me-1" onclick="updateDueEntry('${entry.id}')">Update</button>
            <button class="btn btn-secondary btn-sm" onclick="cancelDueEdit('${entry.id}')">Cancel</button>
          ` : `
            <button class="btn btn-warning btn-sm me-1" onclick="editDueEntry('${entry.id}')">Edit</button>
            <button class="btn btn-danger btn-sm" onclick="deleteDueEntry('${entry.id}')">Delete</button>
          `}
        </td>
      `;
      tbody.appendChild(tr);
    });

    updateDueTotal(displayedData);
  }

  // Helper to generate options for name dropdown in edit mode (uses dropdownNames)
  function getDropdownNamesOptions(selectedName) {
    let options = ''; 
    dropdownNames.forEach(name => {
      const option = document.createElement('option');
      option.value = name;
      option.textContent = name;
      if (String(name) === String(selectedName)) { // Ensure string comparison here too
        option.selected = true;
      }
      options += option.outerHTML; 
    });
    return options;
  }

  // Add Due Entry
  function addDueEntry(e) {
    e.preventDefault();

    const name = document.getElementById('dueName').value;
    const purpose = document.getElementById('duePurpose').value.trim();
    const amount = document.getElementById('dueAmount').value.trim();
    const date = document.getElementById('dueDate').value;
    const status = document.getElementById('dueStatus').value;

    if (!name || !purpose || !amount || !date) {
      showError('Please fill all required fields');
      return;
    }

    const newEntry = { id: Date.now() + Math.random(), name, purpose, amount: Number(amount), date, status, category: 'Due List', isEditing: false, originalAmount: Number(amount) };
    dueEntries.push(newEntry);
    console.log("Added new Due Entry:", newEntry);
    saveData();
    renderDueList();
    clearDueForm();
    showSuccess('Due entry added successfully');
  }

  // Clear Due Form
  function clearDueForm() {
    document.getElementById('dueEntryForm').reset();
  }

  // Edit Due Entry
  function editDueEntry(entryId) {
    console.log("editDueEntry called for entryId:", entryId, "Typeof entryId:", typeof entryId);
    console.log("Current dueEntries array state:", JSON.stringify(dueEntries.map(e => ({id: e.id, name: e.name, type: typeof e.id})), null, 2));

    let foundEntry = false;
    dueEntries = dueEntries.map(entry => {
      if (String(entry.id) === String(entryId)) { // Crucial change: ensure string comparison
        entry.isEditing = true;
        foundEntry = true;
        console.log("Setting isEditing true for:", entry);
      } else {
        entry.isEditing = false; // Ensure only one entry is in editing mode
      }
      return entry;
    });
    if (!foundEntry) {
        console.error("Entry not found in dueEntries for editing after string comparison:", entryId);
    }
    renderDueList();
    console.log("renderDueList called after editDueEntry");
  }

  // Cancel Due Edit
  function cancelDueEdit(entryId) {
    console.log("cancelDueEdit called for entryId:", entryId, "Typeof entryId:", typeof entryId);
    const entry = dueEntries.find(e => String(e.id) === String(entryId)); // Crucial change
    if (entry) {
        entry.isEditing = false;
        console.log("Setting isEditing false for:", entry);
        renderDueList();
    } else {
        console.error("Entry not found in dueEntries for cancelling edit after string comparison:", entryId);
    }
  }

  // Update Due Entry (handles full edit and status change to Paid)
  function updateDueEntry(entryId) {
    console.log("updateDueEntry called for entryId:", entryId, "Typeof entryId:", typeof entryId);
    const entry = dueEntries.find(e => String(e.id) === String(entryId)); // Crucial change
    if (!entry) {
        showError('Entry not found!');
        console.error('Entry not found for update after string comparison:', entryId);
        renderDueList();
        return;
    }

    // Get values from input fields using their IDs
    console.log(`Attempting to get elements for entryId: ${entry.id}`); // Use entry.id here
    const newNameInput = document.getElementById(`editDueName-${entry.id}`); // Use entry.id here
    const newPurposeInput = document.getElementById(`editDuePurpose-${entry.id}`); // Use entry.id here
    const newAmountInput = document.getElementById(`editDueAmount-${entry.id}`); // Use entry.id here
    const newDateInput = document.getElementById(`editDueDate-${entry.id}`); // Use entry.id here
    const newStatusSelect = document.getElementById(`editDueStatus-${entry.id}`); // Use entry.id here

    console.log({newNameInput, newPurposeInput, newAmountInput, newDateInput, newStatusSelect});

    if (!newNameInput || !newPurposeInput || !newAmountInput || !newDateInput || !newStatusSelect) {
        showError('Could not find all input fields for update. Please try again.');
        console.error('Missing input fields for entryId:', entryId, {newNameInput, newPurposeInput, newAmountInput, newDateInput, newStatusSelect});
        return;
    }

    const newName = newNameInput.value;
    const newPurpose = newPurposeInput.value.trim();
    const newAmount = newAmountInput.value.trim();
    const newDate = newDateInput.value;
    const newStatus = newStatusSelect.value;


    if (!newName || !newPurpose || !newAmount || !newDate) {
      showError('Please fill all required fields for update');
      return;
    }

    // Store old values for logging
    const oldName = entry.name;
    const oldPurpose = entry.purpose;
    const oldAmount = entry.amount;
    const oldDate = entry.date;
    const oldStatus = entry.status;

    // Update the entry's fields
    entry.name = newName;
    entry.purpose = newPurpose;
    entry.amount = Number(newAmount); // Update current due amount
    entry.date = newDate;
    entry.isEditing = false; // Turn off editing mode
    entry.status = newStatus; // Update status immediately for consistency

    console.log("Updated Due Entry before status check:", { oldEntry: {name: oldName, purpose: oldPurpose, amount: oldAmount, date: oldDate, status: oldStatus}, newEntry: entry });


    // Handle status change to 'Paid' from direct edit
    if (String(newStatus) === 'Paid') { // Crucial change
        showConfirmation(`Marking this entry as PAID will move it to Paid Report. Are you sure?`, () => {
            // Push to paidEntries with current amount as collected amount
            const paidRecord = {
                id: entry.id, // Keep the same ID for traceability
                name: entry.name,
                purpose: entry.purpose,
                amount: entry.amount, // This is the amount that was due and now paid
                date: new Date().toISOString().split('T')[0], // date of status change
                status: 'Paid',
                category: 'Due List',
                receiptNumber: generateReceiptNumber()
            };
            paidEntries.push(paidRecord);
            console.log("Moved to Paid Report:", paidRecord);
            dueEntries = dueEntries.filter(e => String(e.id) !== String(entryId)); // Crucial change
            saveData();
            renderDueList();
            renderPaidReport();
            showSuccess('Entry fully paid and moved to Paid Report.');
        }, () => {
            // User cancelled, revert status in UI and cancel editing
            entry.status = 'Due'; // Revert to Due
            entry.isEditing = false; // Cancel editing
            saveData(); // Save reverted status
            renderDueList(); // Re-render to show original status
            showError('Operation cancelled.');
        });
    } else {
        // If status remains 'Due' or changed to 'Due' (shouldn't happen here)
        saveData();
        renderDueList();
        showSuccess('Entry updated successfully.');
    }
  }

  // Function called directly by status select dropdown in Due List table
  function updateDueEntryStatusFromSelect(entryId, value) {
    console.log("updateDueEntryStatusFromSelect called for entryId:", entryId, "Typeof entryId:", typeof entryId, "new status:", value);
    const entry = dueEntries.find(e => String(e.id) === String(entryId)); // Crucial change
    if (!entry) {
        console.error('Entry not found for status update after string comparison:', entryId);
        return; // Should not happen
    }
    const oldStatus = entry.status;

    if (String(value) === 'Paid') { // Crucial change
        showConfirmation(`Marking this entry as PAID will move it to Paid Report. Are you sure?`, () => {
            const paidRecord = {
                id: entry.id, // Keep the same ID for traceability
                name: entry.name,
                purpose: entry.purpose,
                amount: entry.amount,
                date: new Date().toISOString().split('T')[0],
                status: 'Paid',
                category: 'Due List',
                receiptNumber: generateReceiptNumber()
            };
            paidEntries.push(paidRecord);
            console.log("Moved to Paid Report from status select:", paidRecord);
            dueEntries = dueEntries.filter(e => String(e.id) !== String(entryId)); // Crucial change
            saveData();
            renderDueList();
            renderPaidReport();
            showSuccess('Entry fully paid and moved to Paid Report.');
        }, () => {
            entry.status = oldStatus; // Revert UI selection if cancelled
            saveData(); // Save reverted status
            renderDueList();
            showError('Operation cancelled.');
        });
    } else {
        // Should not happen for 'Due' list where default is 'Due'
        entry.status = value;
        console.log("Status updated to:", entry.status, "for entry:", entry);
        saveData();
        renderDueList();
        showSuccess('Entry status updated.');
    }
  }


  // Delete Due Entry
  function deleteDueEntry(entryId) {
    console.log("deleteDueEntry called for entryId:", entryId, "Typeof entryId:", typeof entryId);
    showConfirmation('Are you sure you want to delete this entry?', () => {
      dueEntries = dueEntries.filter(e => String(e.id) !== String(entryId)); // Crucial change
      console.log("Entry deleted. Remaining dueEntries:", dueEntries);
      saveData();
      renderDueList();
      showSuccess('Entry deleted successfully');
    });
  }

  // Filter Due List by Name
  function filterDueList() {
    currentDueFilter = document.getElementById('dueFilterName').value; // Update global filter state
    document.getElementById('dueSearchInput').value = ''; // Clear search input
    console.log('Filtering Due List by name:', currentDueFilter); // Debug log
    renderDueList(); // Call without argument
  }

  // Search Due List
  function searchDueList() {
    const searchTerm = document.getElementById('dueSearchInput').value.toLowerCase().trim();
    console.log('Searching Due List for:', searchTerm); // Debug log

    // Always reset the dropdown filter when searching
    document.getElementById('dueFilterName').value = 'all';
    currentDueFilter = 'all';

    if (searchTerm === '') {
        renderDueList(); // Rerender based on 'all' filter (empty search implies all)
        return;
    }

    const filtered = dueEntries.filter(entry => {
        const nameMatch = entry.name.toLowerCase().includes(searchTerm);
        const purposeMatch = entry.purpose.toLowerCase().includes(searchTerm);
        const amountMatch = String(entry.amount).toLowerCase().includes(searchTerm);
        const dateMatch = entry.date.toLowerCase().includes(searchTerm);
        return nameMatch || purposeMatch || amountMatch || dateMatch;
    });
    console.log("Search results for Due List:", filtered);
    renderDueList(filtered); // Render with search results
  }

  // Update Due Total Amount
  function updateDueTotal(entries) {
    let total = 0;
    entries.forEach(e => {
        if (String(e.status) === 'Due') { // Crucial change
            total += e.amount;
            console.log(`Update Due Total: Adding ${e.amount} (Status: ${e.status}) for ${e.name}. Current total: ${total}`);
        } else {
            console.log(`Update Due Total: Skipping ${e.amount} (Status: ${e.status}) for ${e.name}.`);
        }
    });
    document.getElementById('dueTotalAmount').textContent = total.toFixed(2);
    console.log('Final Due Total:', total.toFixed(2));
  }

  // Export Due List PDF
  function exportDuePDF() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    let dataToExport = dueEntries;

    // Apply current filter if not 'all'
    if (currentDueFilter !== 'all') {
        dataToExport = dataToExport.filter(e => String(e.name) === String(currentDueFilter)); // Crucial change
    }
    
    // Apply search term if present
    const searchTerm = document.getElementById('dueSearchInput').value.toLowerCase().trim();
    if (searchTerm !== '') {
        dataToExport = dataToExport.filter(entry => {
            const nameMatch = entry.name.toLowerCase().includes(searchTerm);
            const purposeMatch = entry.purpose.toLowerCase().includes(searchTerm);
            const amountMatch = String(entry.amount).toLowerCase().includes(searchTerm);
            const dateMatch = entry.date.toLowerCase().includes(searchTerm);
            return nameMatch || purposeMatch || amountMatch || dateMatch;
        });
    }
    console.log("Exporting Due List PDF. Data:", dataToExport);
    doc.text('Due List Report', 14, 15);
    doc.autoTable({
      startY: 20,
      head: [['Serial', 'Name', 'Purpose', 'Amount', 'Date', 'Status']],
      body: dataToExport.map((e, i) => [i + 1, e.name, e.purpose, e.amount, e.date, e.status])
    });
    doc.save('due_list_report.pdf');
    showSuccess('Due List exported as PDF');
  }

  // Export Due List Excel
  function exportDueExcel() {
    const wb = XLSX.utils.book_new();
    let dataToExport = dueEntries;

    // Apply current filter if not 'all'
    if (currentDueFilter !== 'all') {
        dataToExport = dataToExport.filter(e => String(e.name) === String(currentDueFilter)); // Crucial change
    }
    
    // Apply search term if present
    const searchTerm = document.getElementById('dueSearchInput').value.toLowerCase().trim();
    if (searchTerm !== '') {
        dataToExport = dataToExport.filter(entry => {
            const nameMatch = entry.name.toLowerCase().includes(searchTerm);
            const purposeMatch = entry.purpose.toLowerCase().includes(searchTerm);
            const amountMatch = String(entry.amount).toLowerCase().includes(searchTerm);
            const dateMatch = entry.date.toLowerCase().includes(searchTerm);
            return nameMatch || purposeMatch || amountMatch || dateMatch;
        });
    }
    console.log("Exporting Due List Excel. Data:", dataToExport);
    const wsData = [
      ['Serial', 'Name', 'Purpose', 'Amount', 'Date', 'Status'],
      ...dataToExport.map((e, i) => [i + 1, e.name, e.purpose, e.amount, e.date, e.status])
    ];
    const ws = XLSX.utils.aoa_to_sheet(wsData);
    XLSX.utils.book_append_sheet(wb, ws, 'Due List Report');
    XLSX.writeFile(wb, 'due_list_report.xlsx');
    showSuccess('Due List exported as Excel');
  }


  // ------------ Incoming Funds Functions ------------

  function renderIncomingList(dataToRender = null) { // Added dataToRender argument
    console.log("renderIncomingList called. Data to render:", dataToRender ? "Filtered Data" : "All Incoming Entries");
    populateNameDropdowns(); // Re-populate to update filter dropdown's options if dropdownNames changed
    const tbody = document.querySelector('#incomingTable tbody');
    tbody.innerHTML = '';
    
    let displayedData = dataToRender;

    if (displayedData === null) { // If no override, apply current filter
        displayedData = currentIncomingFilter === 'all' ? incomingEntries : incomingEntries.filter(e => String(e.name) === String(currentIncomingFilter)); // Crucial change
    }

    displayedData.forEach((entry, index) => {
      console.log(`Rendering Incoming Entry: ID: ${entry.id}, Typeof ID: ${typeof entry.id}, Name: ${entry.name}, isEditing: ${entry.isEditing}, Status: ${entry.status}`);
      const tr = document.createElement('tr');
      // Editable fields logic
      const nameCell = entry.isEditing ? `<select class="form-select" id="editIncomingName-${entry.id}">${getDropdownNamesOptions(entry.name)}</select>` : `<span>${entry.name}</span>`;
      const purposeCell = entry.isEditing ? `<input type="text" class="form-control" value="${entry.purpose}" id="editIncomingPurpose-${entry.id}" />` : `<span>${entry.purpose}</span>`;
      const amountCell = entry.isEditing ? `<input type="number" class="form-control" value="${entry.amount}" min="0" step="any" id="editIncomingAmount-${entry.id}" />` : `<span>${entry.amount}</span>`;
      const dateCell = entry.isEditing ? `<input type="date" class="form-control" value="${entry.date}" id="editIncomingDate-${entry.id}" />` : `<span>${entry.date}</span>`;
      const statusCell = `
        <select class="form-select" id="editIncomingStatus-${entry.id}" onchange="updateIncomingEntryStatusFromSelect('${entry.id}', this.value)" ${entry.isEditing ? '' : 'disabled'}>
          <option value="Due" ${entry.status === 'Due' ? 'selected' : ''}>Due</option>
          <option value="Paid" ${entry.status === 'Paid' ? 'selected' : ''}>Paid</option>
        </select>
      `;

      tr.innerHTML = `
        <td>${index + 1}</td> <!-- Serial Number -->
        <td>${nameCell}</td>
        <td>${purposeCell}</td>
        <td>${amountCell}</td>
        <td>${dateCell}</td>
        <td>${statusCell}</td>
        <td>
          ${entry.isEditing ? `
            <button class="btn btn-success btn-sm me-1" onclick="updateIncomingEntry('${entry.id}')">Update</button>
            <button class="btn btn-secondary btn-sm" onclick="cancelIncomingEdit('${entry.id}')">Cancel</button>
          ` : `
            <button class="btn btn-warning btn-sm me-1" onclick="editIncomingEntry('${entry.id}')">Edit</button>
            <button class="btn btn-danger btn-sm" onclick="deleteIncomingEntry('${entry.id}')">Delete</button>
          `}
        </td>
      `;
      tbody.appendChild(tr);
    });

    updateIncomingTotal(displayedData);
  }

  // Add Incoming Entry
  function addIncomingEntry(e) {
    e.preventDefault();

    const name = document.getElementById('incomingName').value;
    const purpose = document.getElementById('incomingPurpose').value.trim();
    const amount = document.getElementById('incomingAmount').value.trim();
    const date = document.getElementById('incomingDate').value;
    const status = document.getElementById('incomingStatus').value;

    if (!name || !purpose || !amount || !date) {
      showError('Please fill all required fields');
      return;
    }

    const newEntry = { id: Date.now() + Math.random(), name, purpose, amount: Number(amount), date, status, category: 'Incoming Funds', isEditing: false, originalAmount: Number(amount) };
    incomingEntries.push(newEntry);
    console.log("Added new Incoming Entry:", newEntry);
    saveData();
    renderIncomingList();
    clearIncomingForm();
    showSuccess('Incoming entry added successfully');
  }

  // Clear Incoming Form
  function clearIncomingForm() {
    document.getElementById('incomingEntryForm').reset();
  }

  // Edit Incoming Entry
  function editIncomingEntry(entryId) {
    console.log("editIncomingEntry called for entryId:", entryId, "Typeof entryId:", typeof entryId);
    console.log("Current incomingEntries array state:", JSON.stringify(incomingEntries.map(e => ({id: e.id, name: e.name, type: typeof e.id})), null, 2));
    let foundEntry = false;
    incomingEntries = incomingEntries.map(entry => {
      if (String(entry.id) === String(entryId)) { // Crucial change
        entry.isEditing = true;
        foundEntry = true;
        console.log("Setting isEditing true for:", entry);
      } else {
        entry.isEditing = false; // Ensure only one entry is in editing mode
      }
      return entry;
    });
    if (!foundEntry) {
        console.error("Entry not found in incomingEntries for editing after string comparison:", entryId);
    }
    renderIncomingList();
    console.log("renderIncomingList called after editIncomingEntry");
  }

  // Cancel Incoming Edit
  function cancelIncomingEdit(entryId) {
    console.log("cancelIncomingEdit called for entryId:", entryId, "Typeof entryId:", typeof entryId);
    const entry = incomingEntries.find(e => String(e.id) === String(entryId)); // Crucial change
    if (entry) {
        entry.isEditing = false;
        console.log("Setting isEditing false for:", entry);
        renderIncomingList();
    } else {
        console.error("Entry not found in incomingEntries for cancelling edit after string comparison:", entryId);
    }
  }

  // Update Incoming Entry (handles full edit and status change to Paid)
  function updateIncomingEntry(entryId) {
    console.log("updateIncomingEntry called for entryId:", entryId, "Typeof entryId:", typeof entryId);
    const entry = incomingEntries.find(e => String(e.id) === String(entryId)); // Crucial change
    if (!entry) {
        showError('Entry not found!');
        console.error('Entry not found for update after string comparison:', entryId);
        renderIncomingList();
        return;
    }

    // Get values from input fields using their IDs
    console.log(`Attempting to get elements for entryId: ${entry.id}`); // Use entry.id here
    const newNameInput = document.getElementById(`editIncomingName-${entry.id}`); // Use entry.id here
    const newPurposeInput = document.getElementById(`editIncomingPurpose-${entry.id}`); // Use entry.id here
    const newAmountInput = document.getElementById(`editIncomingAmount-${entry.id}`); // Use entry.id here
    const newDateInput = document.getElementById(`editIncomingDate-${entry.id}`); // Use entry.id here
    const newStatusSelect = document.getElementById(`editIncomingStatus-${entry.id}`); // Use entry.id here

    console.log({newNameInput, newPurposeInput, newAmountInput, newDateInput, newStatusSelect});

    if (!newNameInput || !newPurposeInput || !newAmountInput || !newDateInput || !newStatusSelect) {
        showError('Could not find all input fields for update. Please try again.');
        console.error('Missing input fields for entryId:', entryId, {newNameInput, newPurposeInput, newAmountInput, newDateInput, newStatusSelect});
        return;
    }

    const newName = newNameInput.value;
    const newPurpose = newPurposeInput.value.trim();
    const newAmount = newAmountInput.value.trim();
    const newDate = newDateInput.value;
    const newStatus = newStatusSelect.value;


    if (!newName || !newPurpose || !newAmount || !newDate) {
      showError('Please fill all required fields for update');
      return;
    }
    
    // Store old values for logging
    const oldName = entry.name;
    const oldPurpose = entry.purpose;
    const oldAmount = entry.amount;
    const oldDate = entry.date;
    const oldStatus = entry.status;

    entry.name = newName;
    entry.purpose = newPurpose;
    entry.amount = Number(newAmount); // Update current due amount
    entry.date = newDate;
    entry.isEditing = false;
    entry.status = newStatus; // Update status immediately for consistency

    console.log("Updated Incoming Entry before status check:", { oldEntry: {name: oldName, purpose: oldPurpose, amount: oldAmount, date: oldDate, status: oldStatus}, newEntry: entry });

    if (String(newStatus) === 'Paid') { // Crucial change
        showConfirmation(`Marking this entry as PAID will move it to Paid Report. Are you sure?`, () => {
            const paidRecord = {
                id: entry.id, // Keep the same ID for traceability
                name: entry.name,
                purpose: entry.purpose,
                amount: entry.amount,
                date: new Date().toISOString().split('T')[0],
                status: 'Paid',
                category: 'Incoming Funds',
                receiptNumber: generateReceiptNumber()
            };
            paidEntries.push(paidRecord);
            console.log("Moved to Paid Report:", paidRecord);
            incomingEntries = incomingEntries.filter(e => String(e.id) !== String(entryId)); // Crucial change
            saveData();
            renderIncomingList();
            renderPaidReport();
            showSuccess('Entry fully paid and moved to Paid Report.');
        }, () => {
            entry.status = 'Due'; // Revert to Due
            entry.isEditing = false;
            saveData(); // Save reverted status
            renderIncomingList();
            showError('Operation cancelled.');
        });
    } else {
        saveData();
        renderIncomingList();
        showSuccess('Entry updated successfully.');
    }
  }

  // Function called directly by status select dropdown in Incoming Funds table
  function updateIncomingEntryStatusFromSelect(entryId, value) {
    console.log("updateIncomingEntryStatusFromSelect called for entryId:", entryId, "Typeof entryId:", typeof entryId, "new status:", value);
    const entry = incomingEntries.find(e => String(e.id) === String(entryId)); // Crucial change
    if (!entry) {
        console.error('Entry not found for status update after string comparison:', entryId);
        return; // Should not happen
    }
    const oldStatus = entry.status;

    if (String(value) === 'Paid') { // Crucial change
        showConfirmation(`Marking this entry as PAID will move it to Paid Report. Are you sure?`, () => {
            const paidRecord = {
                id: entry.id, // Keep the same ID for traceability
                name: entry.name,
                purpose: entry.purpose,
                amount: entry.amount,
                date: new Date().toISOString().split('T')[0],
                status: 'Paid',
                category: 'Incoming Funds',
                receiptNumber: generateReceiptNumber()
            };
            paidEntries.push(paidRecord);
            console.log("Moved to Paid Report from status select:", paidRecord);
            incomingEntries = incomingEntries.filter(e => String(e.id) !== String(entryId)); // Crucial change
            saveData();
            renderIncomingList();
            renderPaidReport();
            showSuccess('Entry fully paid and moved to Paid Report.');
        }, () => {
            entry.status = oldStatus;
            saveData(); // Save reverted status
            renderIncomingList();
            showError('Operation cancelled.');
        });
    } else {
        entry.status = value;
        console.log("Status updated to:", entry.status, "for entry:", entry);
        saveData();
        renderIncomingList();
        showSuccess('Entry status updated.');
    }
  }


  // Delete Incoming Entry
  function deleteIncomingEntry(entryId) {
    console.log("deleteIncomingEntry called for entryId:", entryId, "Typeof entryId:", typeof entryId);
    showConfirmation('Are you sure you want to delete this entry?', () => {
      incomingEntries = incomingEntries.filter(e => String(e.id) !== String(entryId)); // Crucial change
      console.log("Entry deleted. Remaining incomingEntries:", incomingEntries);
      saveData();
      renderIncomingList();
      showSuccess('Entry deleted successfully');
    });
  }

  // Filter Incoming List by Name
  function filterIncomingList() {
    currentIncomingFilter = document.getElementById('incomingFilterName').value; // Update global filter state
    document.getElementById('incomingSearchInput').value = ''; // Clear search input
    console.log('Filtering Incoming List by name:', currentIncomingFilter); // Debug log
    renderIncomingList(); // Call without argument
  }

  // Search Incoming List
  function searchIncomingList() {
    const searchTerm = document.getElementById('incomingSearchInput').value.toLowerCase().trim();
    console.log('Searching Incoming List for:', searchTerm); // Debug log

    // Always reset the dropdown filter when searching
    document.getElementById('incomingFilterName').value = 'all';
    currentIncomingFilter = 'all';

    if (searchTerm === '') {
        renderIncomingList(); // Rerender based on 'all' filter (empty search implies all)
        return;
    }

    const filtered = incomingEntries.filter(entry => {
        const nameMatch = entry.name.toLowerCase().includes(searchTerm);
        const purposeMatch = entry.purpose.toLowerCase().includes(searchTerm);
        const amountMatch = String(entry.amount).toLowerCase().includes(searchTerm);
        const dateMatch = entry.date.toLowerCase().includes(searchTerm);
        return nameMatch || purposeMatch || amountMatch || dateMatch;
    });
    console.log("Search results for Incoming List:", filtered);
    renderIncomingList(filtered); // Render with search results
  }

  // Update Incoming Total Amount
  function updateIncomingTotal(entries) {
    let total = 0;
    entries.forEach(e => {
        if (String(e.status) === 'Due') { // Crucial change
            total += e.amount;
            console.log(`Update Incoming Total: Adding ${e.amount} (Status: ${e.status}) for ${e.name}. Current total: ${total}`);
        } else {
            console.log(`Update Incoming Total: Skipping ${e.amount} (Status: ${e.status}) for ${e.name}.`);
        }
    });
    document.getElementById('incomingTotalAmount').textContent = total.toFixed(2);
    console.log('Final Incoming Total:', total.toFixed(2));
  }

  // Export Incoming Funds PDF
  function exportIncomingPDF() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    let dataToExport = incomingEntries;

    // Apply current filter if not 'all'
    if (currentIncomingFilter !== 'all') {
        dataToExport = dataToExport.filter(e => String(e.name) === String(currentIncomingFilter)); // Crucial change
    }
    
    // Apply search term if present
    const searchTerm = document.getElementById('incomingSearchInput').value.toLowerCase().trim();
    if (searchTerm !== '') {
        dataToExport = dataToExport.filter(entry => {
            const nameMatch = entry.name.toLowerCase().includes(searchTerm);
            const purposeMatch = entry.purpose.toLowerCase().includes(searchTerm);
            const amountMatch = String(entry.amount).toLowerCase().includes(searchTerm);
            const dateMatch = entry.date.toLowerCase().includes(searchTerm);
            return nameMatch || purposeMatch || amountMatch || dateMatch;
        });
    }
    console.log("Exporting Incoming Funds PDF. Data:", dataToExport);
    doc.text('Incoming Funds Report', 14, 15);
    doc.autoTable({
      startY: 20,
      head: [['Serial', 'Name', 'Purpose', 'Amount', 'Date', 'Status']],
      body: dataToExport.map((e, i) => [i + 1, e.name, e.purpose, e.amount, e.date, e.status])
    });
    doc.save('incoming_funds_report.pdf');
    showSuccess('Incoming Funds exported as PDF');
  }

  // Export Incoming Funds Excel
  function exportIncomingExcel() {
    const wb = XLSX.utils.book_new();
    let dataToExport = incomingEntries;

    // Apply current filter if not 'all'
    if (currentIncomingFilter !== 'all') {
        dataToExport = dataToExport.filter(e => String(e.name) === String(currentIncomingFilter)); // Crucial change
    }
    
    // Apply search term if present
    const searchTerm = document.getElementById('incomingSearchInput').value.toLowerCase().trim();
    if (searchTerm !== '') {
        dataToExport = dataToExport.filter(entry => {
            const nameMatch = entry.name.toLowerCase().includes(searchTerm);
            const purposeMatch = entry.purpose.toLowerCase().includes(searchTerm);
            const amountMatch = String(entry.amount).toLowerCase().includes(searchTerm);
            const dateMatch = entry.date.toLowerCase().includes(searchTerm);
            return nameMatch || purposeMatch || amountMatch || dateMatch;
        });
    }
    console.log("Exporting Incoming Funds Excel. Data:", dataToExport);
    const wsData = [
      ['Serial', 'Name', 'Purpose', 'Amount', 'Date', 'Status'],
      ...dataToExport.map((e, i) => [i + 1, e.name, e.purpose, e.amount, e.date, e.status])
    ];
    const ws = XLSX.utils.aoa_to_sheet(wsData);
    XLSX.utils.book_append_sheet(wb, ws, 'Incoming Funds Report');
    XLSX.writeFile(wb, 'incoming_funds_report.xlsx');
    showSuccess('Incoming Funds exported as Excel');
  }

  // ------------ Due Collect Functions ------------

  function displayCollectionTable(source) {
    console.log("displayCollectionTable called for source:", source);
    const container = document.getElementById('dueCollectTableContainer');
    container.innerHTML = ''; // Clear previous table

    let dataToDisplay = [];
    let tableId = '';
    let headerText = '';
    let tableClass = '';

    if (source === 'due') {
      dataToDisplay = dueEntries.filter(entry => String(entry.status) === 'Due'); // Crucial change
      tableId = 'dueCollectDueTable';
      headerText = 'Due List for Collection';
      tableClass = 'table-primary';
    } else if (source === 'incoming') {
      dataToDisplay = incomingEntries.filter(entry => String(entry.status) === 'Due'); // Crucial change
      tableId = 'dueCollectIncomingTable';
      headerText = 'Incoming Funds for Collection';
      tableClass = 'table-success';
    } else {
      container.innerHTML = '<p class="text-center text-muted p-3">Invalid source selected.</p>';
      return;
    }

    if (dataToDisplay.length === 0) {
        container.innerHTML = `<p class="text-center text-muted p-3">No pending entries in ${headerText.replace(' for Collection', '')}.</p>`;
        return;
    }

    const tableHTML = `
      <h5>${headerText}</h5>
      <table id="${tableId}" class="table table-bordered table-striped align-middle">
        <thead class="${tableClass}">
          <tr>
            <th>Serial</th>
            <th>Name</th>
            <th>Purpose</th>
            <th>Original Amount</th>
            <th>Current Due</th>
            <th>Date</th>
            <th>Collect Amount</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          ${dataToDisplay.map((entry, index) => `
            <tr>
              <td>${index + 1}</td> <!-- Serial Number -->
              <td>${entry.name}</td>
              <td>${entry.purpose}</td>
              <td>${entry.originalAmount ? entry.originalAmount.toFixed(2) : entry.amount.toFixed(2)}</td>
              <td>${entry.amount.toFixed(2)}</td>
              <td>
                <input type="date" class="form-control form-control-sm" id="collectDate-${source}-${entry.id}" value="${new Date().toISOString().split('T')[0]}">
              </td>
              <td>
                <input type="number" class="form-control form-control-sm" id="collectAmount-${source}-${entry.id}" value="${entry.amount.toFixed(2)}" min="0" step="any" max="${entry.amount.toFixed(2)}">
              </td>
              <td>
                <button class="btn btn-info btn-sm" onclick="collectAmount('${source}', '${entry.id}')">Collect</button>
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    `;
    container.innerHTML = tableHTML;
  }

  function collectAmount(source, entryId) {
    console.log(`collectAmount called for source: ${source}, entryId: ${entryId}`);
    const collectAmountInput = document.getElementById(`collectAmount-${source}-${entryId}`);
    const collectDateInput = document.getElementById(`collectDate-${source}-${entryId}`);

    if (!collectAmountInput || !collectDateInput) {
        showError('Collection input fields not found.');
        console.error('Missing collection input fields for', {source, entryId});
        return;
    }

    let collectedAmount = Number(collectAmountInput.value);
    const collectionDate = collectDateInput.value;

    if (isNaN(collectedAmount) || collectedAmount <= 0) {
        showError('Please enter a valid amount to collect.');
        return;
    }

    let entry;
    let originalArray;
    if (source === 'due') {
      entry = dueEntries.find(e => String(e.id) === String(entryId)); // Crucial change
      originalArray = dueEntries;
    } else if (source === 'incoming') {
      entry = incomingEntries.find(e => String(e.id) === String(entryId)); // Crucial change
      originalArray = incomingEntries;
    }

    if (!entry) {
      showError('Entry not found for collection! Please refresh and try again.');
      console.error('Entry not found in original array for collection', {source, entryId});
      return;
    }

    // Ensure collected amount does not exceed current due amount
    if (collectedAmount > entry.amount) {
        collectedAmount = entry.amount; // Cap collected amount to the remaining due amount
        collectAmountInput.value = collectedAmount.toFixed(2); // Update UI to reflect capped amount
        showError(`Collected amount cannot exceed current due. Adjusted to ${collectedAmount.toFixed(2)}.`);
        // Don't return, proceed with the capped amount
    }

    showConfirmation(`Collect ${collectedAmount.toFixed(2)} from ${entry.name} (${entry.purpose})?`, () => {
        const remainingAmount = entry.amount - collectedAmount;

        const paidRecord = {
            id: Date.now() + Math.random(), // New unique ID for the paid record
            sourceEntryId: entry.id, // Keep a reference to the original entry
            name: entry.name,
            purpose: `${cleanPurpose(entry.purpose)} (Collected: ${collectedAmount.toFixed(2)})`, // Add collected tag
            amount: collectedAmount, // This is the amount actually collected
            date: collectionDate, // Use the selected collection date
            status: 'Paid',
            category: entry.category, // e.g., 'Due List' or 'Incoming Funds'
            receiptNumber: generateReceiptNumber()
        };
        paidEntries.push(paidRecord);
        console.log("Added to Paid Report:", paidRecord);

        entry.amount = remainingAmount; // Update remaining amount on original entry

        if (remainingAmount <= 0.01) { // Use a small epsilon for floating point comparison
            // If fully paid, remove from original list
            if (source === 'due') {
                dueEntries = dueEntries.filter(e => String(e.id) !== String(entryId)); // Crucial change
                console.log("Due entry fully paid and removed:", entryId);
            } else if (source === 'incoming') {
                incomingEntries = incomingEntries.filter(e => String(e.id) !== String(entryId)); // Crucial change
                console.log("Incoming entry fully paid and removed:", entryId);
            }
            showSuccess('Amount fully collected and entry moved to Paid Report.');
        } else {
            showSuccess(`Amount collected. Remaining due for ${entry.name}: ${remainingAmount.toFixed(2)}.`);
            console.log("Amount partially collected. Remaining amount:", remainingAmount);
        }
        saveData();
        renderDueList(); // Re-render both lists to update totals and remove entries if fully paid
        renderIncomingList();
        renderPaidReport(); // Update Paid Report
        displayCollectionTable(source); // Re-render the collection table to refresh
    });
  }

  // ------------ Paid Report Functions ------------

  // Render Paid Report table
  function renderPaidReport(dataToRender = null) {
    console.log("renderPaidReport called. Data to render:", dataToRender ? "Filtered Data" : "All Paid Entries");
    populatePaidCategoryFilter(); // Re-populate to ensure categories are up-to-date
    const tbody = document.querySelector('#paidTable tbody');
    tbody.innerHTML = '';

    let displayedData = dataToRender;
    if (displayedData === null) {
        displayedData = currentPaidFilterCategory === 'all' ? paidEntries : paidEntries.filter(e => String(e.category) === String(currentPaidFilterCategory)); // Crucial change
    }
    
    displayedData.forEach((entry, index) => {
      console.log(`Rendering Paid Entry: ID: ${entry.id}, Typeof ID: ${typeof entry.id}, Receipt: ${entry.receiptNumber}, Category: ${entry.category}`);
      const tr = document.createElement('tr');
      // No editing for paid entries, only deletion
      tr.innerHTML = `
        <td>${index + 1}</td> <!-- Serial Number -->
        <td>${entry.receiptNumber}</td>
        <td>${entry.name}</td>
        <td>${entry.purpose}</td>
        <td>${entry.amount.toFixed(2)}</td>
        <td>${entry.date}</td>
        <td>${entry.status}</td>
        <td>${entry.category}</td>
        <td>
          <button class="btn btn-danger btn-sm" onclick="deletePaidEntry('${entry.id}')">Delete</button>
        </td>
      `;
      tbody.appendChild(tr);
    });
    document.getElementById('paidCount').textContent = displayedData.length;
  }

  // Populate Paid Category Filter
  function populatePaidCategoryFilter() {
    const paidFilterCategorySelect = document.getElementById('paidFilterCategory');
    let categories = new Set(paidEntries.map(entry => entry.category));
    
    // Store current value before clearing
    let currentValue = paidFilterCategorySelect.value;

    paidFilterCategorySelect.innerHTML = '<option value="all">All</option>'; // Always start with 'All'
    categories.forEach(category => {
      const option = document.createElement('option');
      option.value = category;
      option.textContent = category;
      paidFilterCategorySelect.appendChild(option);
    });

    // Re-select the current value or default to 'all'
    if (categories.has(currentValue)) {
        paidFilterCategorySelect.value = currentValue;
    } else {
        paidFilterCategorySelect.value = 'all';
    }
    currentPaidFilterCategory = paidFilterCategorySelect.value; // Update global state
  }


  // Delete Paid Entry
  function deletePaidEntry(entryId) {
    console.log("deletePaidEntry called for entryId:", entryId, "Typeof entryId:", typeof entryId);
    showConfirmation('Are you sure you want to delete this paid entry? This action cannot be undone.', () => {
      paidEntries = paidEntries.filter(e => String(e.id) !== String(entryId)); // Crucial change
      console.log("Paid entry deleted. Remaining paidEntries:", paidEntries);
      saveData();
      renderPaidReport();
      showSuccess('Paid entry deleted successfully');
    });
  }

  // Filter Paid Report by Category
  function filterPaidList() {
    currentPaidFilterCategory = document.getElementById('paidFilterCategory').value; // Update global filter state
    document.getElementById('paidSearchInput').value = ''; // Clear search input
    console.log('Filtering Paid Report by category:', currentPaidFilterCategory); // Debug log
    renderPaidReport(); // Call without argument
  }

  // Search Paid Report
  function searchPaidReport() {
    const searchTerm = document.getElementById('paidSearchInput').value.toLowerCase().trim();
    console.log('Searching Paid Report for:', searchTerm); // Debug log

    // Always reset the dropdown filter when searching
    document.getElementById('paidFilterCategory').value = 'all';
    currentPaidFilterCategory = 'all';

    if (searchTerm === '') {
        renderPaidReport(); // Rerender based on 'all' filter (empty search implies all)
        return;
    }

    const filtered = paidEntries.filter(entry => {
        const receiptMatch = entry.receiptNumber ? entry.receiptNumber.toLowerCase().includes(searchTerm) : false;
        const nameMatch = entry.name.toLowerCase().includes(searchTerm);
        const purposeMatch = entry.purpose.toLowerCase().includes(searchTerm);
        const amountMatch = String(entry.amount).toLowerCase().includes(searchTerm);
        const dateMatch = entry.date.toLowerCase().includes(searchTerm);
        const categoryMatch = entry.category.toLowerCase().includes(searchTerm);
        return receiptMatch || nameMatch || purposeMatch || amountMatch || dateMatch || categoryMatch;
    });
    console.log("Search results for Paid Report:", filtered);
    renderPaidReport(filtered); // Render with search results
  }

  // Export Paid Report PDF
  function exportPaidPDF() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    let dataToExport = paidEntries;

    // Apply current filter if not 'all'
    if (currentPaidFilterCategory !== 'all') {
        dataToExport = dataToExport.filter(e => String(e.category) === String(currentPaidFilterCategory)); // Crucial change
    }
    
    // Apply search term if present
    const searchTerm = document.getElementById('paidSearchInput').value.toLowerCase().trim();
    if (searchTerm !== '') {
        dataToExport = dataToExport.filter(entry => {
            const receiptMatch = entry.receiptNumber ? entry.receiptNumber.toLowerCase().includes(searchTerm) : false;
            const nameMatch = entry.name.toLowerCase().includes(searchTerm);
            const purposeMatch = entry.purpose.toLowerCase().includes(searchTerm);
            const amountMatch = String(entry.amount).toLowerCase().includes(searchTerm);
            const dateMatch = entry.date.toLowerCase().includes(searchTerm);
            const categoryMatch = entry.category.toLowerCase().includes(searchTerm);
            return receiptMatch || nameMatch || purposeMatch || amountMatch || dateMatch || categoryMatch;
        });
    }

    console.log("Exporting Paid Report PDF. Data:", dataToExport);
    doc.text('Paid Report', 14, 15);
    doc.autoTable({
      startY: 20,
      head: [['Serial', 'Receipt No.', 'Name', 'Purpose', 'Amount', 'Date', 'Status', 'Category']],
      body: dataToExport.map((e, i) => [i + 1, e.receiptNumber, e.name, e.purpose, e.amount, e.date, e.status, e.category])
    });
    doc.save('paid_report.pdf');
    showSuccess('Paid Report exported as PDF');
  }

  // Export Paid Report Excel
  function exportPaidExcel() {
    const wb = XLSX.utils.book_new();
    let dataToExport = paidEntries;

    // Apply current filter if not 'all'
    if (currentPaidFilterCategory !== 'all') {
        dataToExport = dataToExport.filter(e => String(e.category) === String(currentPaidFilterCategory)); // Crucial change
    }
    
    // Apply search term if present
    const searchTerm = document.getElementById('paidSearchInput').value.toLowerCase().trim();
    if (searchTerm !== '') {
        dataToExport = dataToExport.filter(entry => {
            const receiptMatch = entry.receiptNumber ? entry.receiptNumber.toLowerCase().includes(searchTerm) : false;
            const nameMatch = entry.name.toLowerCase().includes(searchTerm);
            const purposeMatch = entry.purpose.toLowerCase().includes(searchTerm);
            const amountMatch = String(entry.amount).toLowerCase().includes(searchTerm);
            const dateMatch = entry.date.toLowerCase().includes(searchTerm);
            const categoryMatch = entry.category.toLowerCase().includes(searchTerm);
            return receiptMatch || nameMatch || purposeMatch || amountMatch || dateMatch || categoryMatch;
        });
    }
    console.log("Exporting Paid Report Excel. Data:", dataToExport);
    const wsData = [
      ['Serial', 'Receipt No.', 'Name', 'Purpose', 'Amount', 'Date', 'Status', 'Category'],
      ...dataToExport.map((e, i) => [i + 1, e.receiptNumber, e.name, e.purpose, e.amount, e.date, e.status, e.category])
    ];
    const ws = XLSX.utils.aoa_to_sheet(wsData);
    XLSX.utils.book_append_sheet(wb, ws, 'Paid Report');
    XLSX.writeFile(wb, 'paid_report.xlsx');
    showSuccess('Paid Report exported as Excel');
  }

  // ------------ Admin Panel Functions ------------

  // Add Login User
  function addLoginUser(e) {
    e.preventDefault();
    const username = document.getElementById('newUsernameInput').value.trim();
    const password = document.getElementById('newPasswordInput').value.trim();
    const securityQuestion = document.getElementById('newSecurityQuestionInput').value;
    const securityAnswer = document.getElementById('newSecurityAnswerInput').value.trim();

    if (loginUsers.some(user => user.username === username)) {
      showError('Username already exists!');
      return;
    }

    if (!username || !password || !securityQuestion || !securityAnswer) {
      showError('Please fill all fields to add a new user.');
      return;
    }

    loginUsers.push({ username, password, securityQuestion, securityAnswer });
    saveData();
    showSuccess('Login user added successfully!');
    document.getElementById('addLoginForm').reset();
    closeLoginUserModal(); // Close if open to re-render
    showLoginUsers(); // Refresh list immediately if open
  }

  // Show Login Users in a modal
  function showLoginUsers() {
    const list = document.getElementById('loginUserList');
    list.innerHTML = '';
    loginUsers.forEach((user, index) => {
      const li = document.createElement('li');
      li.className = 'list-group-item d-flex justify-content-between align-items-center';
      li.innerHTML = `
        <span>Username: ${user.username} (Password: ${user.password})<br>
        Security Q: ${user.securityQuestion || 'N/A'}<br>
        Security A: ${user.securityAnswer || 'N/A'}</span>
        <div>
          <button class="btn btn-warning btn-sm me-2" onclick="editLoginUser(${index})">Edit</button>
          <button class="btn btn-danger btn-sm" onclick="confirmDeleteLoginUser(${index})">Delete</button>
        </div>
      `;
      list.appendChild(li);
    });
    loginUserModal.show();
  }

  // Close Login User Modal
  function closeLoginUserModal() {
    loginUserModal.hide();
  }

  // Edit Login User (populate modal)
  function editLoginUser(index) {
    const user = loginUsers[index];
    if (user) {
      document.getElementById('editUserIndex').value = index;
      document.getElementById('editUsernameInput').value = user.username;
      document.getElementById('editPasswordInput').value = ''; // Clear password field for security
      document.getElementById('editSecurityQuestionInput').value = user.securityQuestion || '';
      document.getElementById('editSecurityAnswerInput').value = user.securityAnswer || '';
      editLoginUserModal.show();
    }
  }

  // Save Edited Login User
  function saveEditedLoginUser() {
    const index = document.getElementById('editUserIndex').value;
    const user = loginUsers[index];

    if (user) {
      const newUsername = document.getElementById('editUsernameInput').value.trim();
      const newPassword = document.getElementById('editPasswordInput').value.trim();
      const newSecurityQuestion = document.getElementById('editSecurityQuestionInput').value;
      const newSecurityAnswer = document.getElementById('editSecurityAnswerInput').value.trim();

      // Check if new username already exists for another user
      if (loginUsers.some((u, i) => i !== Number(index) && u.username === newUsername)) {
        showError('Username already exists!');
        return;
      }

      user.username = newUsername;
      if (newPassword) { // Only update password if new password is provided
        user.password = newPassword;
      }
      user.securityQuestion = newSecurityQuestion;
      user.securityAnswer = newSecurityAnswer;

      saveData();
      editLoginUserModal.hide();
      showSuccess('Login user updated successfully!');
      showLoginUsers(); // Refresh the list
    }
  }

  // Confirm Delete Login User
  function confirmDeleteLoginUser(index) {
    showConfirmation('Are you sure you want to delete this login user? This action cannot be undone.', () => {
      deleteLoginUser(index);
    });
  }

  // Delete Login User
  function deleteLoginUser(index) {
    if (loginUsers[index].username === 'admin' && loginUsers.length > 1) {
      showError('Cannot delete the default "admin" user if other users exist. Please create another admin user first.');
      return;
    }
    if (loginUsers.length === 1 && loginUsers[index].username === 'admin') {
      showError('Cannot delete the only "admin" user. At least one admin user must exist.');
      return;
    }
    if (loginUsers[index].username === loggedInUser) {
      showError('You cannot delete your own active login session. Please log out first if you wish to delete this account.');
      return;
    }
    loginUsers.splice(index, 1);
    saveData();
    showSuccess('Login user deleted successfully!');
    showLoginUsers(); // Refresh the list
  }

  // Add Name for Dropdowns
  function addDropdownName(e) {
    e.preventDefault();
    const name = document.getElementById('newDropdownNameInput').value.trim();
    if (name && !dropdownNames.includes(name)) {
      dropdownNames.push(name);
      saveData();
      populateNameDropdowns(); // Update all dropdowns
      showSuccess('Name added to dropdowns!');
      document.getElementById('addDropdownNameForm').reset();
    } else if (dropdownNames.includes(name)) {
      showError('Name already exists in dropdowns!');
    } else {
      showError('Please enter a name.');
    }
  }

  // Show Dropdown Names in a modal
  function showDropdownNames() {
    const list = document.getElementById('dropdownNameList');
    list.innerHTML = '';
    dropdownNames.forEach((name, index) => {
      const li = document.createElement('li');
      li.className = 'list-group-item d-flex justify-content-between align-items-center';
      li.innerHTML = `
        <span>${name}</span>
        <button class="btn btn-danger btn-sm" onclick="confirmDeleteDropdownName(${index})">Delete</button>
      `;
      list.appendChild(li);
    });
    dropdownNameModal.show();
  }

  // Close Dropdown Name Modal
  function closeDropdownNameModal() {
    dropdownNameModal.hide();
  }

  // Confirm Delete Dropdown Name
  function confirmDeleteDropdownName(index) {
    showConfirmation('Are you sure you want to delete this name from dropdowns? This will not affect existing entries but the name will no longer appear as an option.', () => {
      deleteDropdownName(index);
    });
  }

  // Delete Dropdown Name
  function deleteDropdownName(index) {
    dropdownNames.splice(index, 1);
    saveData();
    populateNameDropdowns(); // Update all dropdowns
    showSuccess('Name deleted from dropdowns!');
    showDropdownNames(); // Refresh the list
  }

  // Database Backup
  function backupDatabase() {
    const data = {
      dueEntries: dueEntries,
      incomingEntries: incomingEntries,
      paidEntries: paidEntries,
      loginUsers: loginUsers,
      dropdownNames: dropdownNames,
      receiptCounter: receiptCounter
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `mahdi_due_tracker_backup_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showSuccess('Database backed up successfully!');
  }

  // Database Restore
  function restoreDatabase(event) {
    const file = event.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const restoredData = JSON.parse(e.target.result);
          showConfirmation('Restoring the database will overwrite all current data. Are you sure?', () => {
            dueEntries = restoredData.dueEntries || [];
            incomingEntries = restoredData.incomingEntries || [];
            paidEntries = restoredData.paidEntries || [];
            loginUsers = restoredData.loginUsers || [];
            dropdownNames = restoredData.dropdownNames || [];
            receiptCounter = restoredData.receiptCounter || 0;

            // Ensure default admin user exists if no loginUsers are restored or if it's empty
            if (loginUsers.length === 0 || !loginUsers.some(user => user.username === 'admin')) {
                loginUsers.push({ username: 'admin', password: 'password', securityQuestion: 'We need your number to proceed — could you confirm it?', securityAnswer: 'admin' });
            } else {
                // Ensure existing users have securityQuestion and securityAnswer fields after restore
                loginUsers = loginUsers.map(user => {
                    if (user.securityQuestion === undefined) user.securityQuestion = '';
                    if (user.securityAnswer === undefined) user.securityAnswer = '';
                    return user;
                });
            }

            saveData();
            loadData(); // Re-load data to ensure consistency and re-render everything
            renderDueList();
            renderIncomingList();
            renderPaidReport();
            populateNameDropdowns();
            populatePaidCategoryFilter();
            checkLoginStatus(); // Re-check login status as users might have changed
            showSuccess('Database restored successfully!');
          }, () => {
            showError('Database restore cancelled.');
          });
        } catch (error) {
          showError('Failed to parse JSON file: ' + error.message);
          console.error('Restore database error:', error);
        }
      };
      reader.readAsText(file);
      event.target.value = ''; // Reset input
    }
  }

  // Show success modal with message
  function showSuccess(message) {
    console.log("Success:", message);
    successModalBody.textContent = message;
    successModal.show();
    setTimeout(() => successModal.hide(), 2000);
  }

  // Show error modal with message
  function showError(message) {
    console.error("Error:", message);
    errorModalBody.textContent = message;
    errorModal.show();
    setTimeout(() => errorModal.hide(), 3000);
  }

  // Custom Confirmation Modal
  function showConfirmation(message, callback, cancelCallback = null) {
    console.log("Showing confirmation:", message);
    confirmationModalBody.textContent = message;
    confirmCallback = callback;
    confirmActionButton.onclick = () => {
      if (confirmCallback) {
        confirmCallback();
      }
      confirmationModal.hide();
    };
    // If a cancel callback is provided, attach it to the cancel button
    const cancelButton = document.querySelector('#confirmationModal .btn-secondary');
    if (cancelCallback) {
        cancelButton.onclick = () => {
            cancelCallback();
            confirmationModal.hide();
        };
    } else {
        // Default behavior for cancel button if no specific callback
        cancelButton.onclick = () => {
            confirmationModal.hide();
        };
    }
    confirmationModal.show();
  }

  // Forgot Password Functions
  function showForgotPasswordModal() {
    document.getElementById('resetPasswordForm').reset(); // Clear form on open
    forgotPasswordModal.show();
  }

  function resetPassword(e) {
    e.preventDefault();
    const username = document.getElementById('resetUsernameInput').value.trim();
    const securityQuestion = document.getElementById('resetSecurityQuestionInput').value;
    const securityAnswer = document.getElementById('resetSecurityAnswerInput').value.trim();
    const newPassword = document.getElementById('newPasswordResetInput').value.trim();
    const confirmPassword = document.getElementById('confirmPasswordResetInput').value.trim();

    const user = loginUsers.find(u => u.username === username);

    if (!user) {
      showError('User not found.');
      return;
    }

    // Case-insensitive comparison for security answer for user convenience
    if (user.securityQuestion !== securityQuestion || user.securityAnswer.toLowerCase() !== securityAnswer.toLowerCase()) {
      showError('Incorrect security question or answer.');
      return;
    }

    if (newPassword !== confirmPassword) {
      showError('New password and confirm password do not match.');
      return;
    }

    if (newPassword.length < 1) { // Simple validation, can be enhanced
        showError('New password cannot be empty.');
        return;
    }

    user.password = newPassword; // Update the password
    saveData(); // Save changes to localStorage
    forgotPasswordModal.hide();
    showSuccess('Password reset successfully! You can now log in with your new password.');
    document.getElementById('loginForm').reset(); // Clear login form
    document.getElementById('loginError').style.display = 'none'; // Hide any previous login errors
  }

</script>
</body>
</html>
